<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多终端+多Github账户部署Hexo</title>
      <link href="/posts/c87946a8.html"/>
      <url>/posts/c87946a8.html</url>
      
        <content type="html"><![CDATA[<h2 id="需求">需求</h2><ol type="1"><li>实验室和宿舍电脑(Windows)都可以写Hexo博客</li><li>两个Github账户需要共存，一个用于开发，一个用于博客</li></ol><span id="more"></span><h2 id="思路">思路</h2><p><strong>个人情况：</strong></p><p>实验室电脑称作<strong>PC_1</strong>(已配置Hexo)；宿舍电脑称作<strong>PC_2</strong>(未配置Hexo)；用于开发的GitHub账户称作<strong>code</strong>；用于博客的称作<strong>blog</strong></p><p><strong>整体思路：</strong></p><p>在Github账户blog上新建一个仓库(Private或Public都可以)存放Hexo文件，以后不论是哪台电脑写博客都用这个仓库进行同步</p><h2 id="多github账户配置">多Github账户配置</h2><p>所有的终端都需要进行这步配置，之前尝试用 Gum 管理多 GitHub账户，无奈被 Windows自带的凭据管理器搞得心烦意乱，于是柳暗花明又一村，SSH 大法好 : )</p><p><strong>一条明路：</strong>放弃Https吧，改用SSH</p><ol type="1"><li><p>生成两个 ssh key，并分别添加至 code 和 blog</p></li><li><p>配置 config 文件</p><ul><li><p>打开 .ssh目录(默认在<code>C:\Users\XXX\.ssh</code>)，找到 config文件，如果没有就创建一个，不需要后缀</p></li><li><p>修改内容至如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># config for code</span><br><span class="line">Host code.github.com  # 自定义前缀</span><br><span class="line">HostName github.com</span><br><span class="line">IdentityFile C:\\Users\\XXXX\\.ssh\\id_rsa  # 密钥一 路径</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">User username1  # 用户名一</span><br><span class="line"></span><br><span class="line"># config for blog</span><br><span class="line">Host blog.github.com  # 自定义前缀</span><br><span class="line">HostName github.com</span><br><span class="line">IdentityFile C:\\Users\\XXXX\\.ssh\\id_rsa2 # 密钥二 路径</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">User username2  # 用户名二</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试 ssh通信，命令行执行：<code>ssh -T git@xxx.github.com</code>，其中xxx为上一步中的自定义前缀，出现下图结果则通信成功</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/image-20220713153446967.png"alt="image-20220713153446967" /><figcaption aria-hidden="true">image-20220713153446967</figcaption></figure></li><li><p>至此，以后想用哪个 GitHub账号加上对应的前缀即可（不论是clone还是push都需要修改至用<strong>SSH协议</strong>，记得修改<code>_config.yml</code>）</p></li><li><p>附赠一点Git常用指令</p><ul><li><p>更改默认分支名(因为Github默认分支名从master改为了main)：<code>git config --global init.defaultBranch main</code></p></li><li><p>设置全局用户名和邮箱</p><ul><li><p>邮箱：<code>git config --global user.email "YourEmail"</code></p></li><li><p>用户名：<code>git config --global user.name "YourUseName"</code></p></li></ul></li><li><p>设置代理</p><ul><li><p>http：<code>git config --global https.proxy http://127.0.0.1:xxxx</code></p></li><li><p>https：<code>git config --global https.proxy https://127.0.0.1:xxxx</code></p></li></ul></li></ul></li></ol><h2 id="多终端hexo配置">多终端Hexo配置</h2><ul><li><p><strong>PC_1：</strong></p><ol type="1"><li><p>找到 Hexo 原位置，除 <code>.deploy_git</code>以外都复制到另一个空文件夹中</p></li><li><p>检查该目录下有无 <code>.gitignore</code>文件，如果没有则新建一个，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></li><li><p>检查子目录下有无 <code>.git</code>文件夹，有的话删除，不能嵌套上传</p></li><li><p>在 Github 账户 blog 中新建空白仓库Hexo，并将以上文件夹上传至该仓库(直接拖拽或用Git命令)</p></li></ol></li><li><p><strong>PC_2：</strong></p><ol type="1"><li><p>克隆 Hexo 仓库到本地</p></li><li><p>执行以下命令(不需要 <code>hexo init</code>)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>执行<code>hexo s</code>，<code>hexo g</code>，<code>hexo d</code>等命令测试是否成功</p></li></ol></li><li><p><strong>上传和同步Bat脚本：</strong></p><ul><li><p>Hexo部署并上传至Github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:xxxx &amp; <span class="built_in">set</span> https_proxy=http://127.0.0.1:xxxx</span><br><span class="line">call hexo g</span><br><span class="line">call hexo d</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;auto push&quot;</span></span><br><span class="line">git push</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></li><li><p>Hexo拉取并同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:xxxx &amp; <span class="built_in">set</span> https_proxy=http://127.0.0.1:xxxx</span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/main</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用色条</title>
      <link href="/posts/c2ddb321.html"/>
      <url>/posts/c2ddb321.html</url>
      
        <content type="html"><![CDATA[<h2 id="cppcolormap">cppcolormap</h2><p>很多时候我们想把连续或离散的数值用不同的颜色表达，达到漂亮的可视化效果</p><p>这个库提供了很多常用的色条，Github地址：<ahref="https://github.com/tdegeus/cppcolormap">cppcolormap</a></p><span id="more"></span><p>部分色条示例：</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20211221144003.png"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20211221144329.png"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20211221144534.png"/></center><h2 id="使用方法">使用方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xtensor/xio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xtensor/xview.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cppcolormap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> colormap1 = cppcolormap::<span class="built_in">colormap</span>(<span class="string">&quot;jet&quot;</span>, <span class="number">256</span>);</span><br><span class="line"><span class="keyword">auto</span> colormap2 = cppcolormap::<span class="built_in">jet</span>(<span class="number">256</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> colorcycle1 = cppcolormap::<span class="built_in">colorcycle</span>(<span class="string">&quot;tue&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> colorcycle2 = cppcolormap::<span class="built_in">tue</span>();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> r = <span class="built_in">colormap1</span>(i, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">double</span> g = <span class="built_in">colormap1</span>(i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> b = <span class="built_in">colormap1</span>(i, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol type="1"><li>上面两种获取colormap/colorcycle的方式得到的结果是一样的</li><li>不同colormap中的默认颜色数量不一定相同，但是可以显式的指定需要的颜色数，会自动对颜色插值，但colorcycle不行</li><li>最终得到的rgb分量是在 [0,1] 范围内的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 色条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算任意多边形法向量</title>
      <link href="/posts/8c59c543.html"/>
      <url>/posts/8c59c543.html</url>
      
        <content type="html"><![CDATA[<p>和计算面积一样，乍一想，不就是相邻边叉乘？实际上，对于凸多边形确实是这样，但是对于非凸多边形就没那么简单啦<span id="more"></span></p><h2 id="原理">原理</h2><p><strong>Newell's Method</strong>实际上这个方法不仅能确定面的法向量，还可以计算出平面方程</p><p>具体原理: <em>Filippo Tampieri. “Newell's Method for Computing thePlane Equation of a Polygon”. In Graphics Gems III, Academic Press,1992, pp. 231–232.</em></p><h2 id="实现">实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get face normal </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Point&gt;</span><br><span class="line"><span class="function">Vec3d <span class="title">GetFaceNormal</span><span class="params">(<span class="keyword">const</span> std::vector&lt;Point&gt;&amp; points_3d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// use Newell&#x27;s Method to compute the surface normal</span></span><br><span class="line"><span class="function">Vec3d <span class="title">n</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; points_3d.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> j = (i + <span class="number">1</span>) % points_3d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.opengl.org/wiki/Calculating_a_Surface_Normal</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; a = points_3d[i] - points_3d[j];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; b = points_3d[i] + points_3d[j];</span><br><span class="line"></span><br><span class="line">n[<span class="number">0</span>] += (a[<span class="number">1</span>] * b[<span class="number">2</span>]);</span><br><span class="line">n[<span class="number">1</span>] += (a[<span class="number">2</span>] * b[<span class="number">0</span>]);</span><br><span class="line">n[<span class="number">2</span>] += (a[<span class="number">0</span>] * b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get face equation</span></span><br><span class="line"><span class="function">Vec4d <span class="title">GetPlaneEquation</span><span class="params">(<span class="keyword">const</span> std::vector&lt;Point&gt;&amp; points_3d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// use Newell&#x27;s Method to compute the surface normal</span></span><br><span class="line"><span class="function">Vec3d <span class="title">n</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; points_3d.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> j = (i + <span class="number">1</span>) % points_3d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.opengl.org/wiki/Calculating_a_Surface_Normal</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; a = points_3d[i] - points_3d[j];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; b = points_3d[i] + points_3d[j];</span><br><span class="line"></span><br><span class="line">n[<span class="number">0</span>] += (a[<span class="number">1</span>] * b[<span class="number">2</span>]);</span><br><span class="line">n[<span class="number">1</span>] += (a[<span class="number">2</span>] * b[<span class="number">0</span>]);</span><br><span class="line">n[<span class="number">2</span>] += (a[<span class="number">0</span>] * b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">n.<span class="built_in">normalize</span>();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; f_cen = <span class="built_in">GetFaceCentroid</span>(points_3d);</span><br><span class="line"><span class="function">Vec3d <span class="title">cen</span><span class="params">(f_cen[<span class="number">0</span>], f_cen[<span class="number">1</span>], f_cen[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = -cen.<span class="built_in">dot</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Vec4d</span>(n[<span class="number">0</span>], n[<span class="number">1</span>], n[<span class="number">2</span>], d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多边形 </tag>
            
            <tag> 几何基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++计算中值</title>
      <link href="/posts/fe57df27.html"/>
      <url>/posts/fe57df27.html</url>
      
        <content type="html"><![CDATA[<p>Talk is cheap. Show me the code. <span id="more"></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">GetMedianValue</span><span class="params">(std::vector&lt;T&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + vec.<span class="built_in">size</span>() / <span class="number">2</span>, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vec[vec.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 中值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMesh基本用法</title>
      <link href="/posts/6c001b38.html"/>
      <url>/posts/6c001b38.html</url>
      
        <content type="html"><![CDATA[<p>OpenMesh是一个轻量级，易上手的Mesh网处理库(尤其相对于CGAL这种重型库)，支持多边形网格，总之能胜任大多数轻量级任务。</p><ul><li><ahref="https://www.graphics.rwth-aachen.de/media/openmesh_static/Documentations/OpenMesh-8.0-Documentation/index.html">官方文档</a></li><li><ahref="https://gitlab.vci.rwth-aachen.de:9000/OpenMesh/OpenMesh">源码</a></li></ul><p>整理一下它的基本用法：</p><span id="more"></span><h2 id="准备工作">准备工作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;OpenMesh/Core/Mesh/PolyMesh_ArrayKernelT.hh&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;OpenMesh/Core/Utils/PropertyManager.hh&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyTraits</span> :</span> <span class="keyword">public</span> OpenMesh::DefaultTraits</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> OpenMesh::Vec3d Point;  <span class="comment">// use double-values points</span></span><br><span class="line"><span class="keyword">typedef</span> OpenMesh::Vec3d Normal; <span class="comment">// use double-values normal</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> OpenMesh::PolyMesh_ArrayKernelT&lt;MyTraits&gt;  MyMesh;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>我这里用的是PolyMesh_ArrayKernel，如果你的数据是三角网的话，可以用TriMesh_ArrayKernelT</li><li>TriMesh是特殊的PolyMesh，所以PolyMesh Kernel可以读三角网，但是用不了某些TriMesh特有的函数，TriMesh Kernel读不了多边形网</li><li>我更改了OpenMesh的DefaultTrait，将 point 和 normal 的数据类型改成了double，默认是 float</li><li>PropertyManager.hh 是用来增加属性的，后面会用到</li></ul><h2 id="mesh读写">Mesh读写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read Mesh</span></span><br><span class="line">OpenMesh::IO::<span class="built_in">read_mesh</span>(mesh, path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write Mesh</span></span><br><span class="line">OpenMesh::IO::<span class="built_in">write_mesh</span>(mesh, path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read with face color</span></span><br><span class="line">mesh.<span class="built_in">request_face_colors</span>();</span><br><span class="line">OpenMesh::IO::Options ropt;</span><br><span class="line">ropt += OpenMesh::IO::Options::FaceColor;</span><br><span class="line">OpenMesh::IO::<span class="built_in">read_mesh</span>(mesh, path, ropt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write with face color</span></span><br><span class="line">OpenMesh::IO::Options wopt;</span><br><span class="line">wopt += OpenMesh::IO::Options::FaceColor;</span><br><span class="line">OpenMesh::IO::<span class="built_in">write_mesh</span>(mesh, path, wopt);</span><br></pre></td></tr></table></figure><h2 id="mesh属性">Mesh属性</h2><ul><li><p>标准属性</p><p>例如 face color、face normal、vertex normal、halfedgetexcoords2D等等，在使用标准属性之前一定要先申请：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mesh.<span class="built_in">request_face_colors</span>();</span><br><span class="line">mesh.<span class="built_in">request_face_normals</span>();</span><br><span class="line">mesh.<span class="built_in">request_vertex_normals</span>();</span><br><span class="line">mesh.<span class="built_in">request_halfedge_texcoords2D</span>();</span><br></pre></td></tr></table></figure><p>详见 <ahref="https://www.graphics.rwth-aachen.de/media/openmesh_static/Documentations/OpenMesh-8.0-Documentation/a04092.html">standardproperties</a>。</p></li><li><p>自定义属性</p><p>例如对每个面增加一个Plane_3的属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make property</span></span><br><span class="line"><span class="keyword">auto</span> f_plane = OpenMesh::getOrMakeProperty&lt;OpenMesh::FaceHandle, Plane_3&gt;(mesh, <span class="string">&quot;f_plane&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assign property</span></span><br><span class="line">f_plane[f_h] = plane;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get property</span></span><br><span class="line"><span class="keyword">auto</span> f_plane = OM::getProperty&lt;OM::FaceHandle, WSHCGAL::Plane_3&gt;(mesh, <span class="string">&quot;f_plane&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Visit property</span></span><br><span class="line">Plane_3 plane = f_plane[f_h];</span><br></pre></td></tr></table></figure><p>详见 <ahref="https://www.graphics.rwth-aachen.de/media/openmesh_static/Documentations/OpenMesh-8.0-Documentation/a04090.html">Using(custom) properties</a></p></li></ul><h2 id="mesh数据结构访问">Mesh数据结构访问</h2><p>网上很多例子都没有考虑OpenMesh支持的C++11特性，下面介绍一下一些基本用法，一定要学会举一反三：</p><ul><li><p>遍历Mesh中所有的面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f_h : mesh.<span class="built_in">faces</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;face id = &quot;</span> &lt;&lt; f_h.<span class="built_in">idx</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;face valence = &quot;</span> &lt;&lt; mesh.<span class="built_in">valence</span>(f_h) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;face normal = &quot;</span> &lt;&lt; mesh.<span class="built_in">normal</span>(f_h) &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;face color = &quot;</span> &lt;&lt; mesh.<span class="built_in">color</span>(f_h) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;face centroid = &quot;</span> &lt;&lt; mesh.<span class="built_in">calc_face_centroid</span>(f_h) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;face area = &quot; &lt;&lt; mesh.calc_face_area(f_h) &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol type="1"><li>这里的 auto 类型其实是 OpenMesh::SmartFaceHandle。handle是什么？只可意会: )</li><li>计算 face area为什么注释掉了，因为这个函数是TriMesh特有的函数。为什么PolyMesh不给算面积？可能大多人认为计算面积很简单，其实还真是，不管是凸还是非凸多边形，都可以用这种算法计算：<ahref="https://www.wukongblog.com/2021/09/24/计算任意多边形面积/">计算任意多边形面积</a>，不知道OpenMesh为什么不实现一下</li></ol></li><li><p><strong><em>举一反三</em></strong> - &gt;遍历Mesh中所有的点、边、半边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v_h : mesh.<span class="built_in">vertices</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;vertex id = &quot;</span> &lt;&lt; v_h.<span class="built_in">idx</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;vertex normal = &quot;</span> &lt;&lt; mesh.<span class="built_in">normal</span>(v_h) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e_h : mesh.<span class="built_in">edges</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;edge id = &quot;</span> &lt;&lt; e_h.<span class="built_in">idx</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;edge length = &quot;</span> &lt;&lt; mesh.<span class="built_in">calc_edge_length</span>(e_h) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; h_h : mesh.<span class="built_in">halfedges</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;halfedge id = &quot;</span> &lt;&lt; h_h.<span class="built_in">idx</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;halfedge length = &quot;</span> &lt;&lt; mesh.<span class="built_in">calc_edge_length</span>(h_h) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历某个面的所有顶点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v_h : mesh.<span class="built_in">fv_range</span>(f_h))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;vertex id = &quot;</span> &lt;&lt; v_h.<span class="built_in">idx</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><em>举一反三</em></strong> - &gt;遍历某个顶点周围的所有面、遍历面内的所有边和半边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f_h : mesh.<span class="built_in">vf_range</span>(v_h))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;face id = &quot;</span> &lt;&lt; f_h.<span class="built_in">idx</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e_h : mesh.<span class="built_in">fe_range</span>(f_h))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;edge id = &quot;</span> &lt;&lt; e_h.<span class="built_in">idx</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; h_h : mesh.<span class="built_in">fh_range</span>(f_h))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;halfedge id = &quot;</span> &lt;&lt; h_h.<span class="built_in">idx</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="完整示例">完整示例</h2><h3 id="创建一个立方体">创建一个立方体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;OpenMesh/Core/Mesh/PolyMesh_ArrayKernelT.hh&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use DefaultTraits</span></span><br><span class="line"><span class="keyword">typedef</span> OpenMesh::PolyMesh_ArrayKernelT&lt;&gt;  MyMesh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyMesh mesh;</span><br><span class="line">    <span class="comment">// generate vertices</span></span><br><span class="line">    MyMesh::VertexHandle vhandle[<span class="number">8</span>];</span><br><span class="line">    vhandle[<span class="number">0</span>] = mesh.<span class="built_in">add_vertex</span>(MyMesh::<span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">    vhandle[<span class="number">1</span>] = mesh.<span class="built_in">add_vertex</span>(MyMesh::<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">    vhandle[<span class="number">2</span>] = mesh.<span class="built_in">add_vertex</span>(MyMesh::<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    vhandle[<span class="number">3</span>] = mesh.<span class="built_in">add_vertex</span>(MyMesh::<span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    vhandle[<span class="number">4</span>] = mesh.<span class="built_in">add_vertex</span>(MyMesh::<span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">    vhandle[<span class="number">5</span>] = mesh.<span class="built_in">add_vertex</span>(MyMesh::<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">    vhandle[<span class="number">6</span>] = mesh.<span class="built_in">add_vertex</span>(MyMesh::<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">    vhandle[<span class="number">7</span>] = mesh.<span class="built_in">add_vertex</span>(MyMesh::<span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate (quadrilateral) faces</span></span><br><span class="line">    std::vector&lt;MyMesh::VertexHandle&gt;  face_vhandles;</span><br><span class="line">    face_vhandles.<span class="built_in">clear</span>();</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">0</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">1</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">2</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">3</span>]);</span><br><span class="line">    mesh.<span class="built_in">add_face</span>(face_vhandles);</span><br><span class="line"></span><br><span class="line">    face_vhandles.<span class="built_in">clear</span>();</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">7</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">6</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">5</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">4</span>]);</span><br><span class="line">    mesh.<span class="built_in">add_face</span>(face_vhandles);</span><br><span class="line">    face_vhandles.<span class="built_in">clear</span>();</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">1</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">0</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">4</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">5</span>]);</span><br><span class="line">    mesh.<span class="built_in">add_face</span>(face_vhandles);</span><br><span class="line">    face_vhandles.<span class="built_in">clear</span>();</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">2</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">1</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">5</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">6</span>]);</span><br><span class="line">    mesh.<span class="built_in">add_face</span>(face_vhandles);</span><br><span class="line">    face_vhandles.<span class="built_in">clear</span>();</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">3</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">2</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">6</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">7</span>]);</span><br><span class="line">    mesh.<span class="built_in">add_face</span>(face_vhandles);</span><br><span class="line">    face_vhandles.<span class="built_in">clear</span>();</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">0</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">3</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">7</span>]);</span><br><span class="line">    face_vhandles.<span class="built_in">push_back</span>(vhandle[<span class="number">4</span>]);</span><br><span class="line">    mesh.<span class="built_in">add_face</span>(face_vhandles);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!OpenMesh::IO::<span class="built_in">write_mesh</span>(mesh, <span class="string">&quot;output.off&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Cannot write mesh to file &#x27;output.off&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取并访问obj文件的纹理坐标">读取并访问OBJ文件的纹理坐标</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 文件读取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算任意多边形面积</title>
      <link href="/posts/435800e0.html"/>
      <url>/posts/435800e0.html</url>
      
        <content type="html"><![CDATA[<p>乍一听，计算面积不应该是手到擒来的事嘛，其实仔细一想还真不是。多边形是凸的还好说，那非凸的多边形怎么算嘛，难道要把它三角化，再把三角形的面积累加？这时候就有神人提出了 <strong>鞋带算法(shoelacealgorithm)</strong><span id="more"></span></p><h2 id="原理">原理</h2><p>具体的原理我不做赘述，附上几个链接，有兴趣的同学可以深入了解一下：</p><ul><li><a href="https://en.wikipedia.org/wiki/Shoelace_formula">Shoelaceformula - Wikipedia</a></li><li><ahref="%5BArt%20of%20Problem%20Solving%5D(https://artofproblemsolving.com/wiki/index.php/Shoelace_Theorem)">ShoelaceTheorem</a></li></ul><h2 id="实现">实现</h2><ul><li><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get area of any polygon</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_polygon_area</span><span class="params">(<span class="keyword">const</span> std::vector&lt;Point_2&gt;&amp; points_2d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = points_2d.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">double</span> area = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate value of shoelace formula</span></span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; pt_i = points_2d[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; pt_j = points_2d[j];</span><br><span class="line">        area += (pt_j.<span class="built_in">x</span>() + pt_i.<span class="built_in">x</span>()) * (pt_j.<span class="built_in">y</span>() - pt_i.<span class="built_in">y</span>());</span><br><span class="line">        j = i;  <span class="comment">// j is previous vertex to i</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return absolute value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(area / <span class="number">2.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>GeeksforGeeks给出的多语言实现：<ahref="https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/">Areaof a polygon with given n ordered vertices</a></p></li></ul><h2 id="神人">神人</h2><p>那这个提出鞋带算法的神人是谁呢？1795年的 <ahref="https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss">Carl FriedrichGauss</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多边形 </tag>
            
            <tag> 几何基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++生成随机数</title>
      <link href="/posts/88a3a658.html"/>
      <url>/posts/88a3a658.html</url>
      
        <content type="html"><![CDATA[<p>Talk is cheap. Show me the code. <span id="more"></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate random color</span></span><br><span class="line"><span class="function">Color <span class="title">GetRandomColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::random_device rd;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;</span><br><span class="line">std::uniform_int_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">100</span>, <span class="number">256</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Color</span>(<span class="built_in">dist</span>(mt), <span class="built_in">dist</span>(mt), <span class="built_in">dist</span>(mt));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>分以下几个步骤：</p><ol type="1"><li>random_device 生成 min-max 之间的真随机数</li><li>mt19937 随机数引擎</li><li>uniform_int_distribution随机数分布器，生成指定分布如平均分布(uniform_int_distribution、uniform_real_distribution),正态分布(normal_distribution)的随机数</li><li>dist(mt) 生成最终的随机数</li></ol>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++读取任意分隔符文件</title>
      <link href="/posts/90a95f6f.html"/>
      <url>/posts/90a95f6f.html</url>
      
        <content type="html"><![CDATA[<p>Talk is cheap. Show me the code. <span id="more"></span></p><h2 id="空格分隔">空格分隔</h2><p>text:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">9855.1 475.4 235.3</span><br><span class="line">2135.4 756.7 764.4</span><br><span class="line">5433.5 123.4 543.2</span><br><span class="line">3424.3 865.8 235.1</span><br><span class="line">9673.6 853.9 123.6</span><br><span class="line">1563.8 654.3 542.8</span><br><span class="line">2746.9 324.2 243.3</span><br><span class="line">4576.4 556.8 125.5</span><br><span class="line">3454.5 764.1 232.8</span><br></pre></td></tr></table></figure><p>code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read space delimited text file </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadFile</span><span class="params">(<span class="keyword">const</span> std::string&amp; inPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">inFile</span><span class="params">(inPath)</span></span>;</span><br><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(inFile, line))</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="keyword">double</span> X, Y, Z;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (!(iss &gt;&gt; X &gt;&gt; Y &gt;&gt; Z)) </span><br><span class="line">&#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Unknown data format &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">std::cout &lt;&lt; X &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Z &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其他符号分隔">其他符号分隔</h2><p>text:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">9855.1, 475.4, 235.3</span><br><span class="line">2135.4, 756.7, 764.4</span><br><span class="line">5433.5, 123.4, 543.2</span><br><span class="line">3424.3, 865.8, 235.1</span><br><span class="line">9673.6, 853.9, 123.6</span><br><span class="line">1563.8, 654.3, 542.8</span><br><span class="line">2746.9, 324.2, 243.3</span><br><span class="line">4576.4, 556.8, 125.5</span><br><span class="line">3454.5, 764.1, 232.8</span><br></pre></td></tr></table></figure><p>code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read comma delimited text file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadFile</span><span class="params">(<span class="keyword">const</span> std::string&amp; inPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">inFile</span><span class="params">(inPath)</span></span>;</span><br><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(inFile, line))</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">std::array&lt;<span class="keyword">double</span>, 3&gt; coord&#123;&#125;;</span><br><span class="line">std::string value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">getline</span>(iss, value, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">coord[i] = std::<span class="built_in">stod</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; coord[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; coord[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; coord[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StackOverflow yyds!</p>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 文件读取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++获取文件夹下所有文件(包括子文件夹)</title>
      <link href="/posts/86cd5977.html"/>
      <url>/posts/86cd5977.html</url>
      
        <content type="html"><![CDATA[<p>Talk is cheap. Show me the code. <span id="more"></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDir</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> std::string&amp; dir,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> std::string&amp; extension,</span></span></span><br><span class="line"><span class="params"><span class="function">std::vector&lt;std::string&gt;&amp; filelist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; entry : fs::<span class="built_in">directory_iterator</span>(dir))</span><br><span class="line">&#123;</span><br><span class="line">fs::path fPath = entry.<span class="built_in">path</span>();</span><br><span class="line"><span class="keyword">if</span> (fs::<span class="built_in">is_directory</span>(fPath))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ListDir</span>(fPath.<span class="built_in">string</span>(), extension, filelist);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fs::<span class="built_in">is_regular_file</span>(fPath))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fPath.<span class="built_in">has_extension</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fPath.<span class="built_in">extension</span>().<span class="built_in">string</span>().<span class="built_in">compare</span>(extension) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">filelist.<span class="built_in">emplace_back</span>(fPath.<span class="built_in">string</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>filesystem是C++17才有的功能，所以C++语言标准至少设置为C++17</p></li><li><p>此函数会递归的遍历所有子文件夹</p></li></ul><p>用法：</p><ul><li>dir 为文件夹路径</li><li>extension 为想获取的文件后缀，如 '.jpg'</li><li>filelist 为最后输出的文件路径数组</li></ul>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS快捷键集合</title>
      <link href="/posts/4f174e2f.html"/>
      <url>/posts/4f174e2f.html</url>
      
        <content type="html"><![CDATA[<p>总结了一下 Visual Studio 最最最有用的快捷键，下文中的 *是指按快捷键时光标放在当前行任意位置即可，无需选中，熟悉了这个操作可以大大提高效率。</p><span id="more"></span><h2 id="复制粘贴">复制粘贴</h2><p>复制粘贴作为程序猿的第一要义，要把它的快捷键用的滚瓜烂熟才行</p><table><thead><tr class="header"><th>按键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>Ctrl + D</td><td>原地复制粘贴当前行*</td></tr><tr class="even"><td>Ctrl + C</td><td>复制当前行*</td></tr><tr class="odd"><td>Ctrl + V</td><td>粘贴到上一行*</td></tr><tr class="even"><td>Ctrl + X</td><td>剪切当前行*</td></tr><tr class="odd"><td>Ctrl + Z</td><td>撤销操作</td></tr><tr class="even"><td>Ctrl + Shift + L</td><td>删除当前行*</td></tr><tr class="odd"><td>Ctrl + Shift + V</td><td>打开vs剪贴板</td></tr><tr class="even"><td>Win + V</td><td>打开win10剪贴板（更推荐使用）</td></tr></tbody></table><h2 id="快速编辑">快速编辑</h2><p>Alt + ↑ 或 ↓ 推荐尝试</p><table><colgroup><col style="width: 31%" /><col style="width: 68%" /></colgroup><thead><tr class="header"><th>按键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>双击左键</td><td>快速选中光标所在的单词</td></tr><tr class="even"><td>三击左键</td><td>快速选中当前行</td></tr><tr class="odd"><td>Alt + 鼠标左键</td><td>列编辑模式</td></tr><tr class="even"><td>Alt + ↑ 或 ↓</td><td>将当前行上下移动*</td></tr><tr class="odd"><td>Ctrl + ← 或 →</td><td>光标快速移动（按单词跳过会比按字母跳过快很多）</td></tr><tr class="even"><td>Shift + ← 或 →</td><td>用键盘左右选取内容</td></tr><tr class="odd"><td>Ctrl + Shift + ← 或 →</td><td>用键盘快速左右选中内容</td></tr><tr class="even"><td>Alt + Shift + ↑ 或 ↓</td><td>用键盘上下选中内容</td></tr></tbody></table><h2 id="调试相关">调试相关</h2><table><colgroup><col style="width: 21%" /><col style="width: 78%" /></colgroup><thead><tr class="header"><th>按键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>F9</td><td>设置断点*</td></tr><tr class="even"><td>F5</td><td>开始调试，跳转到下个断点</td></tr><tr class="odd"><td>Ctrl + F5</td><td>开始执行（非调试状态）</td></tr><tr class="even"><td>F10</td><td>逐过程（直接执行完当前行）</td></tr><tr class="odd"><td>Ctrl + F10</td><td>运行到光标处*</td></tr><tr class="even"><td>F11</td><td>逐语句（会深入进当前行执行）</td></tr><tr class="odd"><td>Shift + F11</td><td>跳出当前块</td></tr><tr class="even"><td>鼠标拖动黄色箭头</td><td>执行到指定位置，注意可以往回拖，也就是时光倒流（有可能出问题）</td></tr></tbody></table><h2 id="跳转">跳转</h2><table><thead><tr class="header"><th>按键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>F12</td><td>转到定义</td></tr><tr class="even"><td>Ctrl + F12</td><td>转到声明</td></tr><tr class="odd"><td>Alt + F12</td><td>速览定义</td></tr><tr class="even"><td>Shift + F12</td><td>查找所有引用</td></tr><tr class="odd"><td>Ctrl + K + T</td><td>查看调用层次结构</td></tr><tr class="even"><td>Ctrl + ]</td><td>光标定位至对应的另一个括号</td></tr><tr class="odd"><td>Ctrl + G</td><td>定位至某行</td></tr><tr class="even"><td>Ctrl + -</td><td>向后导航</td></tr><tr class="odd"><td>Ctrl + Shift + -</td><td>向前导航</td></tr><tr class="even"><td>Ctrl + F</td><td>开启查找</td></tr><tr class="odd"><td>F3</td><td>开启查找后，向后查找</td></tr><tr class="even"><td>Ctrl + F3</td><td>开启查找后，向前查找</td></tr></tbody></table><h2 id="其他">其他</h2><table><thead><tr class="header"><th>按键</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>Ctrl + S</td><td>保存（建议随手点击，养成肌肉记忆）</td></tr><tr class="even"><td>Ctrl + Shift + S</td><td>保存全部文件</td></tr><tr class="odd"><td>Ctrl + K + D</td><td>整理代码格式</td></tr><tr class="even"><td>Ctrl + K + C</td><td>注释所选内容</td></tr><tr class="odd"><td>Ctrl + K + U</td><td>取消注释所选内容</td></tr><tr class="even"><td>Ctrl + M + L</td><td>折叠/展开所有代码块（大纲显示）</td></tr><tr class="odd"><td>Ctrl + B</td><td>生成项目</td></tr><tr class="even"><td>Ctrl + Shift + B</td><td>生成解决方案</td></tr><tr class="odd"><td>Ctrl + Pause/Break</td><td>取消生成</td></tr><tr class="even"><td>Ctrl + R + R</td><td>重命名变量</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> visual studio </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度到底是什么</title>
      <link href="/posts/f36b55d7.html"/>
      <url>/posts/f36b55d7.html</url>
      
        <content type="html"><![CDATA[<p>相信有很多人也一直搞不清深度的概念，最近仔细推导了一遍，记录一下。<span id="more"></span></p><h2 id="几何关系">几何关系</h2><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/geometrygraph.png" style="zoom: 80%;" /></center><p>上图中 <span class="math inline">\(O\)</span> 为投影中心，<spanclass="math inline">\(O-XYZ\)</span> 为相机坐标系，<spanclass="math inline">\(o-xy\)</span> 为像素坐标系，<spanclass="math inline">\(P\)</span> 为一物点，<spanclass="math inline">\(p\)</span> 为该物点对应的像点。</p><h2 id="基本公式">基本公式</h2><p>我们先不考虑 <span class="math inline">\(f_x\)</span> 和 <spanclass="math inline">\(f_y\)</span>，由上图中很明显的两个相似三角形可以得到： <span class="math display">\[\begin{equation}\frac{x_i-x_0}{X_c} =\frac{y_i-y_0}{Y_c}= \frac{f}{Z_c}\end{equation}\]</span> 乘开后得到： <span class="math display">\[\begin{equation}Z_c\cdot x_i=f\cdot X_c + Z_c\cdot x_0\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}Z_c\cdot y_i={f\cdot Y_c}+Z_c\cdot y_0\end{equation}\]</span></p><p>写成矩阵形式： <span class="math display">\[\begin{equation}\begin{bmatrix}Z_c\cdot x_i\\Z_c\cdot x_i\\Z_c\end{bmatrix}=\begin{bmatrix}f&amp;0&amp;x_0\\0&amp;f&amp;y_0\\0&amp;0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_c\\Y_c\\Z_c \end{bmatrix}\end{equation}\]</span> 欸嘿，我们推出了 <span class="math inline">\(K\)</span>矩阵，将等式左边改写： <span class="math display">\[\begin{equation}\begin{bmatrix}u\\v\\w \end{bmatrix}=\begin{bmatrix}f&amp;0&amp;x_0\\0&amp;f&amp;y_0\\0&amp;0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_c\\Y_c\\Z_c \end{bmatrix}\end{equation}\]</span> 那么： <span class="math display">\[x_i=u/w\]</span></p><p><span class="math display">\[y_i=v/w\]</span></p><p><span class="math display">\[w=Z_c\]</span></p><p>现在，考虑 <span class="math inline">\(f_x\)</span> 和 <spanclass="math inline">\(f_y\)</span> ，就可以得到： <spanclass="math display">\[\begin{equation}\begin{bmatrix}u\\v\\w \end{bmatrix}=\begin{bmatrix}f_x&amp;0&amp;x_0\\0&amp;f_y&amp;y_0\\0&amp;0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_c\\Y_c\\Z_c \end{bmatrix}\end{equation}\]</span> 经过上面的推导，我们发现了什么，<spanclass="math inline">\(w=Z_c\)</span>？没错，<spanclass="math inline">\(w\)</span> 就是传说中的<strong>深度</strong>。</p><h2 id="深度">深度</h2><p>深度：物点到投影中心的垂距，即 <spanclass="math inline">\(Z_c\)</span>。</p><p>这时候有人可能会问了， <span class="math inline">\(Z_c\)</span>不是相机坐标系下的物点坐标吗，深度不是应该用世界坐标系下的坐标计算吗？</p><p>事实上，我们要明确一件事，在我们思考整个成像过程的时候，一个便于理解的思维模式是：想象物点的位置是保持不变的，所有的R和t都是针对坐标系的变化。有了这个思维模式，我们就清楚了，世界坐标系和相机坐标系之间只有R和t的变换，并没有涉及到尺度的变化，所以，世界坐标系和相机坐标系的尺度是一致的，量纲是一致的，<spanclass="math inline">\(Z_c\)</span> 就是深度，<spanclass="math inline">\(t\)</span> 和 <spanclass="math inline">\(C\)</span> 都是由几何意义的(<ahref="https://www.wukongblog.com/2021/04/02/%E7%9B%B8%E5%AF%B9%E5%AE%9A%E5%90%91%E4%B8%AD%E7%9A%84tij%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/#more">相对定向中的tij到底是什么</a>)。</p><h2 id="思考">思考</h2><ul><li><p>已知物点坐标和P矩阵，可以得到像点坐标和深度</p></li><li><p>已知像点坐标和P矩阵，则无法直接求出物点坐标，只能得到物点和投影中心连线的这根光线，有了深度，才能确定物点坐标</p></li><li><p>最后再把公式整理一下吧：</p></li></ul><p><span class="math display">\[\begin{equation}\begin{bmatrix}x_i\\y_i\\1 \end{bmatrix}=\frac{1}{w}\cdot\begin{bmatrix}f_x&amp;0&amp;x_0\\0&amp;f_y&amp;y_0\\0&amp;0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_c\\Y_c\\Z_c \end{bmatrix}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{bmatrix}X_c\\Y_c\\Z_c \end{bmatrix}= w\cdot\begin{bmatrix}\frac{1}{f_x}&amp;0&amp;\text{-}\frac{x_0}{f_x}\\0&amp;\frac{1}{f_y}&amp;\text{-}\frac{y_0}{f_y}\\0&amp;0&amp;1\end{bmatrix}\cdot\begin{bmatrix}x_i\\y_i\\1 \end{bmatrix}\end{equation}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影测量 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 深度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维重建流程(总结)</title>
      <link href="/posts/d21b54ef.html"/>
      <url>/posts/d21b54ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>从计算机视觉和摄影测量两种角度详细梳理一下三维建模的整体流程，计划长期更新:)</p><span id="more"></span><h2 id="计算机视觉">计算机视觉</h2><p>完整的三维重建流程包括以下几步：</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/20210409105625.png" style="zoom: 80%;" /></center><h3 id="运动中恢复位姿">运动中恢复位姿</h3><ul><li>sequential/incremental SfM</li></ul><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/20210409102905.png" style="zoom: 80%;" /></center><ul><li>global SfM</li></ul><h3 id="多视角立体几何">多视角立体几何</h3><h3 id="表面重建">表面重建</h3><h3 id="纹理映射">纹理映射</h3><h3 id="推荐阅读">推荐阅读</h3><ul><li>CVPR大规模三维建模指南：<ahref="https://demuc.de/tutorials/cvpr2017/">CVPR</a></li><li>AliceVision三维建模流程：<ahref="https://alicevision.org/#photogrammetry">AliceVision</a></li><li>COLMAP官方文档：<ahref="https://colmap.github.io/tutorial.html">COLMAP</a></li><li>openMVG官方文档：<ahref="https://openmvg.readthedocs.io/en/latest/openMVG/openMVG/">openMVG</a></li></ul><h2 id="摄影测量">摄影测量</h2>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
            <tag> 摄影测量 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相对定向中的tij到底是什么</title>
      <link href="/posts/92fc1748.html"/>
      <url>/posts/92fc1748.html</url>
      
        <content type="html"><![CDATA[<p>之前一直搞不清公式里各种 <span class="math inline">\(t\)</span>的实际含义，最近仔细推导了一遍，记录一下。<span id="more"></span></p><h2 id="基本公式">基本公式</h2><ul><li><p>世界坐标系 -&gt; 相机坐标系 <span class="math display">\[\begin{equation}\begin{bmatrix}X_c\\Y_c\\Z_c \end{bmatrix}=R\cdot\begin{bmatrix}X_w\\Y_w\\Z_w\end{bmatrix}+t\end{equation}\]</span> 写成齐次化的形式： <span class="math display">\[\begin{equation}\begin{bmatrix}X_c\\Y_c\\Z_c\\1 \end{bmatrix}=\begin{bmatrix}R&amp;t\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_w\\Y_w\\Z_w\\1\end{bmatrix}\end{equation}\]</span> 其中 <span class="math inline">\(R\)</span> 为 <em>globalrotation matrix</em> 全局旋转矩阵，<spanclass="math inline">\(t\)</span> 为 <em>global translation</em>全局平移量。这里的 <span class="math inline">\(R\)</span>很好理解，其将世界坐标系旋转到了相机坐标系下，而 <spanclass="math inline">\(t\)</span>的含义为：<strong>相机坐标系下世界坐标系原点的位置</strong>，比较难懂。怎么理解呢，可以脑补一下，由于<span class="math inline">\(R\)</span>正交矩阵的性质，坐标系旋转时，原点位置不变，向量长度不变，也就是旋转后的世界坐标系和相机坐标系完全平行，只差一个平移量<spanclass="math inline">\(t\)</span>，这个平移量就是相机坐标系下世界坐标系原点的坐标。</p><p>摄影测量中外方位元素中的线元素，我们通常用 <spanclass="math inline">\(C\)</span>来表示，其含义为：<strong>世界坐标系下相机坐标系原点的位置，也就是世界坐标系下相机的位置</strong>。这样一来，两者的转换公式也就一目了然： <span class="math display">\[\begin{equation}t=-R\cdot C\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}  C=-R^T\cdot t\end{equation}\]</span></p></li><li><p>相机坐标系 -&gt; 相机坐标系 <span class="math display">\[\begin{equation}\begin{bmatrix}X_j\\ Y_j\\ Z_j \end{bmatrix} =R_{ij}\cdot \begin{bmatrix}X_i\\ Y_i\\ Z_i \end{bmatrix}+t_{ij}\end{equation}\]</span> 写成齐次化的形式： <span class="math display">\[\begin{equation}\begin{bmatrix}X_j\\ Y_j\\ Z_j\\1 \end{bmatrix} =\begin{bmatrix}R_{ij}&amp;t_{ij}\\0&amp;1\end{bmatrix}\cdot \begin{bmatrix}X_i\\ Y_i\\ Z_i\\1 \end{bmatrix}\end{equation}\]</span> 其中 <span class="math inline">\(R_{ij}\)</span> 为<em>relative rotation matrix</em> 相对旋转矩阵，<spanclass="math inline">\(t_{ij}\)</span> 为 <em>relative translation</em>相对平移量。和世界坐标系 -&gt; 相机坐标系类似，<spanclass="math inline">\(R_{ij}\)</span> 表示将 <spanclass="math inline">\(i\)</span> 坐标系旋转至 <spanclass="math inline">\(j\)</span> 坐标系，<spanclass="math inline">\(t_{ij}\)</span> 表示 <spanclass="math inline">\(j\)</span> <strong>相机坐标系下</strong> <spanclass="math inline">\(i\)</span><strong>相机坐标系原点的位置</strong>。</p><p>同样的，我们常说的相对定向线元素 <spanclass="math inline">\(C_{ij}\)</span> 表示 <spanclass="math inline">\(i\)</span> <strong>相机坐标系下</strong> <spanclass="math inline">\(j\)</span><strong>相机坐标系原点的位置</strong>。两者的转换公式为： <spanclass="math display">\[\begin{equation}t_{ij}=-R_{ij}\cdot C_{ij}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}C_{ij}=-R_{ij}^T\cdot t_{ij}\end{equation}\]</span> 那么 <span class="math inline">\(R_{ij}\)</span> 和 <spanclass="math inline">\(t_{ij}\)</span>怎么通过全局旋转平移量来表达呢？</p></li></ul><h2 id="相对定向元素">相对定向元素</h2><p>有了公式(6)后，我们将两张影像 <spanclass="math inline">\(i,j\)</span> 与物方关系的方程写出： <spanclass="math display">\[\begin{equation}\begin{bmatrix}X_i\\Y_i\\Z_i\\1 \end{bmatrix}=\begin{bmatrix}R_{i}&amp;t_{i}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_w\\Y_w\\Z_w\\1\end{bmatrix}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{bmatrix}X_j\\Y_j\\Z_j\\1\end{bmatrix}=\begin{bmatrix}R_{j}&amp;t_{j}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_w\\Y_w\\Z_w\\1\end{bmatrix}\end{equation}\]</span></p><p>将公式(9)(10)代入公式(6)中得到： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{j}&amp;t_{j}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_w\\Y_w\\Z_w\\1\end{bmatrix}=\begin{bmatrix}R_{ij}&amp;t_{ij}\\0&amp;1\end{bmatrix}\cdot \begin{bmatrix}R_{i}&amp;t_{i}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_w\\Y_w\\Z_w\\1\end{bmatrix}\end{equation}\]</span></p><p>物方点坐标相同，消掉后： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{j}&amp;t_{j}\\0&amp;1\end{bmatrix}=\begin{bmatrix}R_{ij}&amp;t_{ij}\\0&amp;1\end{bmatrix}\cdot \begin{bmatrix}R_{i}&amp;t_{i}\\0&amp;1\end{bmatrix}\end{equation}\]</span> 将等号右边乘开： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{j}&amp;t_{j}\\0&amp;1\end{bmatrix}=\begin{bmatrix}R_{ij}\cdot R_i &amp; R_{ij}\cdot t_i+t_{ij}\\0&amp;1\end{bmatrix}\end{equation}\]</span> 这样就得到了相对定向元素与全局旋转平移量的关系： <spanclass="math display">\[\begin{equation}R_j=R_{ij}\cdot R_i\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}t_j = R_{ij}\cdot t_i+t_{ij}\end{equation}\]</span> 即： <span class="math display">\[\begin{equation}R_{ij}=R_{j}\cdot R_i^T\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}t_{ij}=t_{j}-R_{ij}\cdot t_i\end{equation}\]</span> 考虑 <span class="math inline">\(t_{ij}\)</span> 尺度影响：<span class="math display">\[\begin{equation}s\cdot t_{ij}=t_{j}-R_{ij}\cdot t_i\end{equation}\]</span></p><h2 id="应用">应用</h2><h3 id="使用gps坐标做全局线元素初值">使用GPS坐标做全局线元素初值</h3><p>我们认为当前的全局坐标系与GPS坐标系只差了一个旋转关系，则有： <spanclass="math display">\[\begin{equation}R_{gps}=R_{glo2gps}\cdot R_{global}\end{equation}\]</span></p><p><span class="math inline">\(R_{glo2gps}\)</span>可以通过两两相机间的向量求解，写出GPS坐标系 -&gt; 相机坐标系的关系：<span class="math display">\[\begin{equation}\begin{bmatrix}X_i\\Y_i\\Z_i\\1 \end{bmatrix}=\begin{bmatrix}R_{gps_i}&amp;t_{gps_i}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_{gps}\\Y_{gps}\\Z_{gps}\\1\end{bmatrix}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{bmatrix}X_j\\Y_j\\Z_j\\1 \end{bmatrix}=\begin{bmatrix}R_{gps_j}&amp;t_{gps_j}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_{gps}\\Y_{gps}\\Z_{gps}\\1\end{bmatrix}\end{equation}\]</span></p><p>将以上两个公式代入公式(6)中： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{gps_j}&amp;t_{gps_j}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_{gps}\\Y_{gps}\\Z_{gps}\\1\end{bmatrix}=\begin{bmatrix}R_{ij}&amp;t_{ij}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}R_{gps_i}&amp;t_{gps_i}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_{gps}\\Y_{gps}\\Z_{gps}\\1\end{bmatrix}\end{equation}\]</span></p><p>物方点坐标相同，消掉后： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{gps_j}&amp;t_{gps_j}\\0&amp;1\end{bmatrix}=\begin{bmatrix}R_{ij}&amp;t_{ij}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}R_{gps_i}&amp;t_{gps_i}\\0&amp;1\end{bmatrix}\end{equation}\]</span></p><p>即： <span class="math display">\[\begin{equation}R_{gps_j}=R_{ij}\cdot R_{gps_i}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}t_{gps_j}=R_{ij}\cdot t_{gps_i}+t_{ij}\end{equation}\]</span></p><p>可以看出，方程的基本形式没有变化，这里要注意，全局坐标系的旋转不影响相对定向中<span class="math inline">\(R_{ij}\)</span> 和 <spanclass="math inline">\(t_{ij}\)</span>的数值，可以从它们的实际意义去思考一下。</p><h3 id="arcore坐标系转真实世界坐标系">ARCore坐标系转真实世界坐标系</h3><p>之前我们遇到的问题都是物方坐标相同，求两个相机坐标系之间的关系，这个问题是相机坐标系相同，求两个世界坐标系之间的关系。ARCore的世界坐标系(记为Local)为开启软件一瞬间的手机位置，我们想把它转为我们自定义的世界坐标系(记为Global)以实现室内定位。</p><p>我们现有的数据为：</p><ul><li>Local坐标系 -&gt; 相机坐标系的 <spanclass="math inline">\(R_{L}\)</span> 和 <spanclass="math inline">\(t_{L}\)</span></li><li>Global坐标系 -&gt; 相机坐标系的<spanclass="math inline">\(R_G\)</span> 和 <spanclass="math inline">\(t_G\)</span></li></ul><p>待求的值为：</p><ul><li>Local坐标系 -&gt; Global坐标系的 <spanclass="math inline">\(R_{LG}\)</span> 和 <spanclass="math inline">\(t_{LG}\)</span></li></ul><p>先写出两世界坐标系转换的方程： <span class="math display">\[\begin{equation}\begin{bmatrix}X_G\\ Y_G\\ Z_G\\1 \end{bmatrix} =\begin{bmatrix}R_{LG}&amp;t_{LG}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_L\\ Y_L\\ Z_L\\1 \end{bmatrix}\end{equation}\]</span> 再写出两个世界坐标系转相机坐标系的方程： <spanclass="math display">\[\begin{equation}\begin{bmatrix}X^{&#39;}\\Y^{&#39;}\\Z^{&#39;}\\1 \end{bmatrix}=\begin{bmatrix}R_{L}&amp;t_{L}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_L\\Y_L\\Z_L\\1\end{bmatrix}\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}\begin{bmatrix}X^{&#39;}\\Y^{&#39;}\\Z^{&#39;}\\1 \end{bmatrix}=\begin{bmatrix}R_{G}&amp;t_{G}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}X_G\\Y_G\\Z_G\\1\end{bmatrix}\end{equation}\]</span></p><p>和上文一样，代入后得到： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{G}&amp;t_{G}\\0&amp;1\end{bmatrix}^{\text{-1}}\cdot\begin{bmatrix}X^{&#39;}\\Y^{&#39;}\\Z^{&#39;}\\1 \end{bmatrix}=\begin{bmatrix}R_{LG}&amp;t_{LG}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}R_{L}&amp;t_{L}\\0&amp;1\end{bmatrix}^{\text{-1}}\cdot\begin{bmatrix}X^{&#39;}\\Y^{&#39;}\\Z^{&#39;}\\1 \end{bmatrix}\end{equation}\]</span> 相机坐标系相同，消掉后： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{G}&amp;t_{G}\\0&amp;1\end{bmatrix}^{\text{-1}}=\begin{bmatrix}R_{LG}&amp;t_{LG}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}R_{L}&amp;t_{L}\\0&amp;1\end{bmatrix}^{\text{-1}}\end{equation}\]</span> 即： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{L}&amp;t_{L}\\0&amp;1\end{bmatrix}=\begin{bmatrix}R_{G}&amp;t_{G}\\0&amp;1\end{bmatrix}\cdot\begin{bmatrix}R_{LG}&amp;t_{LG}\\0&amp;1\end{bmatrix}\end{equation}\]</span> 乘开： <span class="math display">\[\begin{equation}\begin{bmatrix}R_{L}&amp;t_{L}\\0&amp;1\end{bmatrix}=\begin{bmatrix}R_{G}\cdot R_{LG}&amp;R_{G}\cdot t_{LG}+t_{G}\\0&amp;1\end{bmatrix}\end{equation}\]</span> 得到： <span class="math display">\[\begin{equation}R_{LG}=R_G^T\cdot R_L\end{equation}\]</span></p><p><span class="math display">\[\begin{equation}t_{LG}=R_G^T\cdot (t_L-t_G)\end{equation}\]</span></p><h2 id="小结">小结</h2><ol type="1"><li><p>markdown+latex写公式很nice</p></li><li><p>感受到了公式齐次化的优美与强大之处:D​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影测量 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 相对定向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++抓取摄像头实时图像</title>
      <link href="/posts/3d39ce11.html"/>
      <url>/posts/3d39ce11.html</url>
      
        <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>实时抓取网络摄像头图像至C++ OpenCV数组，进行后续处理。</p><h2 id="思路">思路</h2><p>原本想通过RTSP协议，使用OpenCV自带的videocapture函数截取视频流中的图像，但是发现延迟很高，差不多有3-4秒，于是放弃该思路。<span id="more"></span></p><p>咨询卖家后发现，该摄像头不仅支持RTSP协议，还提供http抓图接口，于是思路变为如何在C++里使用http接口获取图像，Google之后找到如下代码。代码中用到了openCV库和libcurl库。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">http://benjithian.sg/2012/12/load-image-from-memoryweb-using-opencv-and-libcurl/</span></span><br><span class="line"><span class="comment">Below is the C++ codes to load an image directly from a website without it being written to the hard disk.</span></span><br><span class="line"><span class="comment">Library used were OpenCV and Libcurl. Do tell me if there is a more efficient way to do it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//curl writefunction to be passed as a parameter</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">write_data</span><span class="params">(<span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, <span class="keyword">void</span>* userdata)</span> </span>&#123;</span><br><span class="line">std::ostringstream* stream = (std::ostringstream*)userdata;</span><br><span class="line"><span class="keyword">size_t</span> count = size * nmemb;</span><br><span class="line">stream-&gt;<span class="built_in">write</span>(ptr, count);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function to retrieve the image as Cv::Mat data type</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">curlImg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CURL* curl;</span><br><span class="line">CURLcode res;</span><br><span class="line">std::ostringstream stream;</span><br><span class="line">curl = <span class="built_in">curl_easy_init</span>();</span><br><span class="line"><span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_URL, <span class="string">&quot;http://192.168.1.88/tmpfs/snap.jpg?usr=admin&amp;pwd=admin&quot;</span>); <span class="comment">//the img url</span></span><br><span class="line"><span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEFUNCTION, write_data); <span class="comment">// pass the writefunction</span></span><br><span class="line"><span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEDATA, &amp;stream); <span class="comment">// pass the stream ptr when the writefunction is called</span></span><br><span class="line">res = <span class="built_in">curl_easy_perform</span>(curl); <span class="comment">// start curl</span></span><br><span class="line">std::string output = stream.<span class="built_in">str</span>(); <span class="comment">// convert the stream into a string</span></span><br><span class="line"><span class="built_in">curl_easy_cleanup</span>(curl); <span class="comment">// cleanup</span></span><br><span class="line">std::vector&lt;<span class="keyword">char</span>&gt; data = std::vector&lt;<span class="keyword">char</span>&gt;(output.<span class="built_in">begin</span>(), output.<span class="built_in">end</span>()); <span class="comment">//convert string into a vector</span></span><br><span class="line">cv::Mat data_mat = cv::<span class="built_in">Mat</span>(data); <span class="comment">// create the cv::Mat datatype from the vector</span></span><br><span class="line">cv::Mat image = cv::<span class="built_in">imdecode</span>(data_mat, <span class="number">1</span>); <span class="comment">//read an image from memory buffer</span></span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cv::Mat image = <span class="built_in">curlImg</span>();</span><br><span class="line">cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Image output&quot;</span>, <span class="number">0</span>);</span><br><span class="line">cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image output&quot;</span>, image); <span class="comment">//display image</span></span><br><span class="line">cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">cv::<span class="built_in">destroyWindow</span>(<span class="string">&quot;Image output&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/20210327172307.png" style="zoom: 80%;" /></center><h2 id="摄像头">摄像头</h2><p>本想买一个类似openMV的开发板，但总感觉有点大材小用，再加上成本问题就没有选它。上文使用的摄像头在某宝的店铺为隆胜监控，支持的网络协议很全，接口也很好用，支持定做无畸变镜头，感觉还不错:D</p><p>附上一张各开发板对比图：</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/摄像头.png" style="zoom: 80%;" /></center>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> libcurl </tag>
            
            <tag> 摄像头 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于影像结构线特征的建筑规则化(2016)</title>
      <link href="/posts/f19d5c1e.html"/>
      <url>/posts/f19d5c1e.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>基于立体相机的建筑三维重建不可避免的要遭受噪声的影响，使得其缺乏规则性(表现在线特征是否平直，同质区域是否平滑)。本文<ahref="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>利用线特征构建了一种新的表面脚手架结构，用于模型规则化。规则化由两个迭代步骤组成：(1)线特征是在影像上根据亮度和几何信息半自动提取的；(2)脚手架的空间拓扑结构根据数据忠诚度和拓扑规则进行优化，之后Mesh网通过向脚手架调整达到优化。我们的方法有两个优点：首先，提出的脚手架结构能够准确的描述建筑结构的语义信息。其次，脚手架结构是嵌入在Mesh网中的，能够保留Mesh的连通性，避免表面的畸变和相交现象。<span id="more"></span></p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/20210408114105.png" style="zoom: 70%;" /></center><h2 id="贡献">贡献</h2><ul><li><p>一种新型的脚手架(scaffold)结构，能准确地描述建筑结构，保持模型的规则</p></li><li><p>一种噪声不敏感的支架结构加固方法(通过推导三维线性特征之间的正确空间关系)，并根据推导出的拓扑结构优化表面形状</p></li><li><p>自动/交互式的直线提取，同时利用亮度，几何，城市先验知识</p></li></ul><h2 id="相关工作">相关工作</h2><ul><li>自动化方法</li><li>交互式方法</li><li>基于拓扑约束的方法</li></ul><h2 id="方法概述">方法概述</h2><h3 id="scaffolding">Scaffolding</h3><h4 id="surface-scaffold-structure">Surface Scaffold Structure</h4><p>输入Mesh网，<spanclass="math inline">\(\mathcal{M}=\left(\mathcal{V}_{m},\mathcal{E}_{m}\right)\)</span> ，<spanclass="math inline">\(\mathcal{V}_{m}\)</span> 为点集，<spanclass="math inline">\(\mathcal{E}_{m}\)</span>为边集，引入<strong><em>surface scaffold structure</em></strong>进行规则化。表面脚手架结构包括：</p><ul><li>3D线特征集合 <spanclass="math inline">\(\mathcal{F}=\left\{F_{i}\right\}, i \in[1,N]\)</span>，<span class="math inline">\(F_i\)</span>为Mesh网上的一条直线，由一系列相连的边组成。每个<spanclass="math inline">\(F_i\)</span> 都是由影像直线 <spanclass="math inline">\(l_i\)</span> 反投影得来。</li><li>脚手架 <span class="math inline">\(\mathcal{S}\)</span>，由一系列的脚手架直线 <spanclass="math inline">\(\mathcal{L_s}=\{L_i\},i\in[1,N]\)</span>组成。定义脚手架图，表示其拓扑结构。</li></ul><p>我们将Mesh网上的顶点投影至它们对应的脚手架直线上，并对Mesh网的其他部分进行平滑，这样就达到了规则化的效果。</p><h4 id="scaffold-topology">Scaffold Topology</h4><p>由于脚手架直线是由2D线反投影而来，由于噪声不可避免的会出现错误。因此，我们对脚手架的拓扑结构进行优化。</p><p>通常，如果两个3D线的端点足够近，它们则为 <strong><em>incidentlines</em></strong>(相交)。但是，由于点位置不一定准确，一些距离较近的平行线会被错误定义为incident lines。因此，仅用端点的邻近度来衡量线是否 incident是不足够的。所以，我们需要精准的定义邻近端点的空间关系，以便进行脚手架拓扑结构优化。</p><p><strong><em>Local point-wise(LPW) relation</em></strong>考虑到位置邻近的先决条件，我们对距离小于阈值 <spanclass="math inline">\(\epsilon_{d}\)</span> 的两个端点 <spanclass="math inline">\(P_{z}^{i}\)</span> and <spanclass="math inline">\(P_{z^{\prime}}^{j}\)</span> 引入 LPW 关系 <spanclass="math inline">\(r=\left(P_{z}^{i},P_{z^{\prime}}^{j}\right)\)</span>。LPW关系定义为以下四种类型(Fig.2)：</p><ul><li><em>Contiguous</em>，两端点属于同一条线</li><li><em>Incident</em>，两端点属于不同的直线但是位置相同</li><li><em>Parallel</em>，两平行线中距离最近的端点对</li><li><em>Other</em>，不是以上三种类型</li></ul><p><strong><em>Scaffold graph</em></strong> <spanclass="math inline">\(\mathcal{G_s}=\left(\mathcal{V}_{s},\mathcal{E}_{s}\right)\)</span>，用于表示和优化脚手架的拓扑结构，包含所有的LPW关系。一开始，LPW关系类型是未知的，我们的目标是准确的提取出它们的LPW关系。</p><p><strong><em>Relation clique</em></strong>由于incidence或parallel存在传播性，即若{a, b}和{b,c}为LPW中的Incident，则{a, c}也为Incident，Parallel同理。这样 <spanclass="math inline">\(\mathcal{G_s}\)</span> 中有 Incident or Parallel关系的组件就形成了一个relation clique (关系圈)，如{a, b,c}。同时，原始的边集并没有包含所有的关系，比如{a,c}，我们把这种由传播关系得到的边作为补充边加入 <spanclass="math inline">\(\mathcal{G_s}\)</span> 中，如Fig.3a。</p><p><strong><em>Relation clique graph</em></strong> 我们用关系圈图 <spanclass="math inline">\(\mathcal{G}_{c}=\left(\mathcal{C}_{I} \bigcup\mathcal{C}_{P}, \mathcal{E}_{c}\right)\)</span> 来解决拓扑矛盾，<spanclass="math inline">\(\mathcal{C}_{I}\)</span> 和 <spanclass="math inline">\(\mathcal{C}_{P}\)</span> 表示提取出的 incidentclique set 和 parallel clique set。在 <spanclass="math inline">\(\mathcal{G}_{c}\)</span>中，两个clique的关系通过边来连接，Fig.3b表示了从Fig.3a中推理的来的relation clique graph。</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326113324.png" style="zoom: 82%;"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326113602.png" style="zoom: 82%;"/></center><h4 id="workflow">Workflow</h4><p>预处理阶段，我们通过<a href="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>中的方法检测小洞，并用平面修复。</p><p><strong><em>Automatic phase</em></strong>绿色部分，首先选出具有正确几何信息的相机最小集，通过简化一个 viewredundancy graph，参考<a href="#fn3" class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a>。其次，我们自动提取尽可能多的脚手架线，组成脚手架图，优化脚手架拓扑关系(非线性最小二乘问题)，将Mesh网上的边投影至优化后的脚手架线。</p><p><strong><em>Interactive phase</em></strong>黄色部分，脚手架线通过人工干预不断变多。随着 interactive stage 和scaffold consolidation的不断迭代，脚手架不断完善，Mesh网逐渐规则化。</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326113459.png" style="zoom: 82%;"/></center><h3 id="automatic-joint-2d-3d-line-proposal">Automatic Joint 2D-3D LineProposal</h3><h4 id="view-selection">View Selection</h4><p>减少影像冗余，提高线特征提取效率。参考<a href="#fn4"class="footnote-ref" id="fnref4"role="doc-noteref"><sup>4</sup></a>，我们挑选了一系列的影像，具有最精准的标定，在满足完全覆盖条件下数量最小。该问题可以通过在满足覆盖条件下贪婪的删除标定最不准的影像解决。</p><h4 id="accurate-and-coherent-2d-line-extraction">Accurate and Coherent2D Line Extraction</h4><p>首先，我们通过影像金字塔，在不同尺度的影像上提取2D直线。这些在不同尺度下提取的线倾向于共线和重叠，即描述同一条线。我们将这些倾向于共线的线段收集成组，然后对每一组从对应的影像区域求得一个最终的直线。对于一个影像区域<span class="math inline">\(\sigma\)</span>，我们找出使以下两项最大化的尺度。 <span class="math display">\[\begin{array}{l}A(s)=-\log \left(\frac{1}{|\sigma|} \sum_{l \in \mathcal{L}_{\sigma}(s)}\sum_{x \in l} \nabla_{\mathbf{v}_{l}} I(x)\right) \\U(s)=-\sum_{l \in \mathcal{L}_{\sigma}(s)} P(l) \log P(l)\end{array}\]</span> <span class="math inline">\(A(s)\)</span>为精度项，描述直线强度，<span class="math inline">\(U(s)\)</span>为连贯项，描述直线的分段状况也即直线的熵。Fig.6c为提取的结果，相比于Canny 和 LSD 我们提取的线更干净，更连贯。Fig.5是Fig.6 黑框区域的放大视图，其颜色代表不同的尺度。</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/20210326171751.png" style="zoom: 80%;" /></center><h4 id="learning-based-line-filtering">Learning-Based LineFiltering</h4><p>上述过程提取出的2D线存在很多纹理线而不是结构线，会导致后续的3D脚手架结构线出错，我们可以通过几何特性来滤除纹理线。我们构建了一个二元分类器，用AdaBoost<a href="#fn5" class="footnote-ref" id="fnref5"role="doc-noteref"><sup>5</sup></a>算法求解，它可以很好地综合多种弱分类器(<em>weakclassifiers</em>)。Fig.6d中的不同颜色代表不同的View。</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326160212.png" style="zoom: 80%;" /></center><h3 id="surface-scaffold-structure-consolidation">Surface ScaffoldStructure Consolidation</h3><h4 id="mesh-line-generation-and-scaffold-line-initialization">Mesh LineGeneration and Scaffold Line Initialization</h4><p>用 <span class="math inline">\(F\)</span> 来表示Mesh线，<spanclass="math inline">\(L\)</span> 来表示脚手架线，<spanclass="math inline">\(l\)</span> 来表示影像线。首先，将 <spanclass="math inline">\(l\)</span> 反投影至 <spanclass="math inline">\(\mathcal{M}\)</span>，得到一系列被覆盖的顶点 <spanclass="math inline">\(\mathcal{P}_l\)</span>，如Fig.7a。然后，通过RANSAC从点集<span class="math inline">\(\mathcal{P}_l\)</span> 中拟合出 <spanclass="math inline">\(L\)</span>。最终，<spanclass="math inline">\(F\)</span> 为距离 <spanclass="math inline">\(L\)</span> 最近的边的集合，通过建立有向图 <spanclass="math inline">\(\mathcal{G}_l\)</span>求解，详见 Algorithm 1。</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326155835.png" style="zoom: 80%;" /></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326155957.png" style="zoom: 80%;" /></center><h4 id="scaffold-topology-optimization">Scaffold TopologyOptimization</h4><p>拓扑优化时应该同时考虑数据忠诚度和拓扑约束，在不引入拓扑矛盾的情况下最小化labeling代价，详见Algorithm2。</p><h5 id="energy-function-formulation">Energy Function Formulation</h5><h5 id="energy-minimization">Energy Minimization</h5><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326160349.png" style="zoom: 60%;" /></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326182059.png" style="zoom: 80%;" /></center><h3 id="global-shape-refinement">Global Shape Refinement</h3><p>拓扑优化后，可以通过调整脚手架线的位置和方向进行Mesh网的优化。</p><h3 id="interactive-structure-driven-scaffolding">InteractiveStructure-Driven Scaffolding</h3><h4 id="user-interface">User Interface</h4><h4 id="symmetry-based-scaffold-line-proposal">Symmetry-Based ScaffoldLine Proposal</h4><h2 id="结果">结果</h2><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326113418.png" style="zoom: 80%;"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326174914.png" style="zoom: 80%;" /></center><h2 id="参考文献">参考文献</h2><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Wang J, Fang T, Su Q, et al.Image-based building regularization using structural linear features[J].IEEE transactions on visualization and computer graphics, 2015, 22(6):1760-1772.、<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>T. K. Dey, K. Li, and J. Sun, “Oncomputing handle and tunnel loops,” in Proc. Int. Conf. Cyberworlds,2007, pp. 357–366.<a href="#fnref2" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>S. Zhu, T. Fang, R. Zhang, and L.Quan, “Multi-view geometry compression,” in Proc. 12th Asian Conf.Comput. Vis., 2015, pp. 3–18.<a href="#fnref3" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p>S. Zhu, T. Fang, R. Zhang, and L.Quan, “Multi-view geometry compression,” in Proc. 12th Asian Conf.Comput. Vis., 2015, pp. 3–18.<a href="#fnref4" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn5" role="doc-endnote"><p>R. Rojas, “Adaboost and the superbowl of classifiers a tutorial introduction to adaptive boosting,” FreieUniv., Berlin, Germany, 2009.<a href="#fnref5" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 文献研读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
            <tag> Mesh </tag>
            
            <tag> 规则化 </tag>
            
            <tag> 线特征 </tag>
            
            <tag> 直线提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于平面的城市三维重建模型规则化(2017)</title>
      <link href="/posts/662cb92b.html"/>
      <url>/posts/662cb92b.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>提出了一种将体三维重建(<em>volumetric3D reconstruction</em>)和平面拟合(<em>planefitting</em>)方法混合的城市三维重建方法，以获得去噪和简洁的场景表示。我们的方法基于一个已经建立的四面体占有率标签(<em>tetrahedraloccupancylabeling</em>)方法，同时我们针对城市重建做了改进，增加了其与平面对齐的可能性。更进一步的，我们为其添加了正则项(<em>regularizationterms</em>)，使其更偏好曼哈顿式结构，同时我们也添加了用来控制模型的细节层级的数据项。</p><span id="more"></span><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/20210408114223.png" style="zoom: 80%;" /></center><h2 id="贡献">贡献</h2><ul><li><p>提出了一个统一的三维重建框架，在不显式执行曼哈顿结构，以及用户指定的平滑度和详细程度属性的同时，有利于平面和正交结构</p></li><li><p>方法具有一般性，这使得它非常适合重建任何混合的城市和自然场景，以及室内和室外的场景。</p></li></ul><h2 id="相关工作">相关工作</h2><ul><li><p><strong>基元拟合 Primitive Fitting</strong></p><p>曼哈顿世界假设(<em>Manhattan-world assumption</em>)</p></li><li><p><strong>室内城市重建 Urban Scene Reconstruction</strong></p></li><li><p><strong>室外城市重建 Outdoor SceneReconstruction</strong></p></li><li><p><strong>一般的3D重建方法 Generic 3D ReconstructionApproachs</strong></p></li><li><p><strong>混合的3D重建方法 Hybrid 3D ReconstructionApproachs</strong></p></li></ul><h2 id="方法概述">方法概述</h2><p>输入点云平面检测完成后，用Delaunay方法将点云分成四面体。与一般的基于四面体的三维重建<ahref="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>类似，我们计算的重建表面为一个四面体内外标记的界面。为了确保检测出的平面为解决方案的一部分，我们通过平面于四面体相交的方式扩充了解空间。同时我们加入了分段平滑项(更偏爱曼哈顿式的结构)和更进一步的数据项(用来控制数据的细节层级LOD)。</p><h3 id="平面检测plane-detection">平面检测(Plane Detection)</h3><ul><li><p>基于RANSAC检测平面</p></li><li><p>每个平面对应一组inlier点(与平面距离小于<spanclass="math inline">\(d_{inlier}\)</span>)，<spanclass="math inline">\(d_{inlier}\)</span>定义为整个点云中点到点最小距离的中位数*5</p></li><li><p>对于每个平面，用MeanShift<a href="#fn3" class="footnote-ref"id="fnref3"role="doc-noteref"><sup>3</sup></a>方法聚类，这样每个平面又被分割为几个平面部件(<em>planesegments</em>)</p></li></ul><h3id="基于平面的点云降噪plane-based-point-cloud-denoising">基于平面的点云降噪(Plane-basedPoint Cloud Denoising)</h3><ul><li>我们把与平面距离<spanclass="math inline">\(d_{inlier}\)</span>内的所有点都视为平面的噪声样本</li><li>为了消除这种小噪声，我们将所有inlier点投影到平面上</li><li>这大致上保持了点云的原始点密度，比<a href="#fn4"class="footnote-ref" id="fnref4"role="doc-noteref"><sup>4</sup></a>中平面的密集过采样更有效，从而使平面成为四面体化的一部分，相比之下，如果有必要，我们将对四面体进行细分</li></ul><h3 id="点云四面体化point-cloud-tetrahedralization">点云四面体化(PointCloud Tetrahedralization)</h3><ul><li>通过Delaunay三角化将点云四面体化</li></ul><h3id="四面体占用标签tetrahedra-occupancy-labeling">四面体占用标签(TetrahedraOccupancy Labeling)</h3><p>我们的目标是计算一个水密面作为两个不相交的集合之间的界面，这两个集合将场景中的每个四面体标记为内部或外部。因此，这个表面可以用二值标签{0,1}来完全描述。最终，我们用公式表示为以下最优化问题：</p><p><span class="math display">\[\underset{\ell}{\operatorname{minimize}} \quadE_{\mathrm{Vis}}(\ell)+\alpha_{\operatorname{Man}}E_{\operatorname{Man}}(\ell)+\alpha_{\mathrm{LoD}}E_{\mathrm{LoD}}(\ell)\]</span></p><p>每一项都偏好不同的属性。 <spanclass="math inline">\(E_{\mathrm{Vis}}\)</span>代表四面面的可见性，<spanclass="math inline">\(E_{\operatorname{Man}}\)</span>代表更支持曼哈顿式的结构，<spanclass="math inline">\(E_{\mathrm{LoD}}\)</span>允许做LoD层级调整。我们用图割来求取该问题的全局最优解，下面会详细介绍能量函数中的每一项。</p><h3id="基于可见性的代价visibility-based-unary-and-pairwise-costs">基于可见性的代价(Visibility-basedUnary and Pairwise Costs)</h3><p>对于每个cell和每个face，用影像-像点关系来计算可见性信息，<spanclass="math inline">\(E_{\mathrm{Vis}}\)</span>的定义参考<a href="#fn5"class="footnote-ref" id="fnref5"role="doc-noteref"><sup>5</sup></a>。</p><ul><li><p>Unary Costs</p><p>每个cell都包含一个相机，每个<em>infinite cell</em> 加<em>infiniteweight</em>标记为outside。对每个点，如果其在某个点后面(从相机看)，标记为inside。因此，在点后的cell得到<em>infinite weight</em> 。</p></li><li><p>Pairwise Costs</p><p>因为，面不可能存在于测量点前，所以，每个面若是与相机-物点光线相交，则会得到一个恒定的惩罚权重。</p></li></ul><h3 id="四面体细分tetrahedra-subdivision">四面体细分(TetrahedraSubdivision)</h3><p>之前点云降噪过程得到的平面，并不是四面体必要的一部分，因此我们需要平面和四面体相交，以确保所有的平面都可以被四面体的面表示。对每一条边，如果它与平面部分相交，我们将沿着平面细分所有该边所在的四面体。但简单的将一个四面体分成两部分，不足以维持其邻接关系，所以我们有一套细分策略。细分后的四面体不一定满足Delaunay特性，但是我们在后续步骤中也不需要其保持这个特性。</p><p>因为细分后的四面体本身没有可视性代价，我们需要重新计算。对于 unarycost，我们为其分配按四面体体积加权后的原始代价，对于 pairwisecost，如果该面是原始面的一部分，按新面的面积加权。对于其他的面，我们按一定的策略进行代价传播，原始四面体中满足与新面夹角足够小的最大面被选中，加权公式<ahref="#fn6" class="footnote-ref" id="fnref6"role="doc-noteref"><sup>6</sup></a>P6。</p><p>通过这种传播方式，unary cost 保持一致，pairwise cost从尽可能与新面接近的面传播得到。</p><h3id="平面感知的规则化plane-aware-regularization">平面感知的规则化(Plane-AwareRegularization)</h3><p>我们引入了一种新的正则项，他允许一个在通用3D重建和预定计划重建按(如曼哈顿式重建)间做出连续选择。</p><ul><li><p>Manhattan Regularity Term</p><p>与<a href="#fn7" class="footnote-ref" id="fnref7"role="doc-noteref"><sup>7</sup></a>类似，我们提出了一个偏好正交和平行的结构的规则项。下述项偏好在曼哈顿结构式(相邻面的角度接近0或90°的倍数)进行标签转变:<span class="math display">\[E_{\operatorname{Man}}(\ell)=\sum_{f \in T}\mathbf{1}_{\left\{\ell_{t_{1}} \neq \ell_{t_{2}}\right\}}\frac{a_{f}}{3} \sum_{e \in f} \min _{g \in \mathcal{N}_{e}}\{|\sin (2\angle(f, g))|\}\]</span> 其中，<span class="math inline">\(f\)</span> 表示四面体集合<span class="math inline">\(T\)</span> 中的一个面，<spanclass="math inline">\({1}_{\left\{\cdot\right\}}\)</span>为指示函数，<span class="math inline">\(\ell_{t_{1}}\)</span> 和 <spanclass="math inline">\(\ell_{t_{2}}\)</span> 是面 <spanclass="math inline">\(f\)</span> 相邻的两个四面体的标签，<spanclass="math inline">\(a_{f}\)</span> 为面 <spanclass="math inline">\(f\)</span> 的面积，<spanclass="math inline">\(e\)</span> 为 <spanclass="math inline">\(f\)</span> 的边，<spanclass="math inline">\(\mathcal{N}_{e}\)</span> 为边 <spanclass="math inline">\(e\)</span>所在的所有面。这一项的最大优点即为其更偏好曼哈顿式结构，但其不是严格限定，也允许任何的表面类型。此外，这一项完全为局部操作，不需要与世界坐标系的任意一个轴平行。</p></li><li><p>Level of Detail Term</p><p>为了控制因曼哈顿项去除的细节数量，以及对预先检测出的平面的偏好，我们提出了另外一项，用来控制删除的结构数量。例如，我们想去除建筑屋顶上的噪声，但是想保留烟囱。为了达到这个目的，这一项会对与不加入正则项重建的模型之间的偏差进行惩罚。原始的，没有平面感知的3D重建可以用<span class="math inline">\(\ell^{\text {Labatut }}=\arg \min_{\ell}\left[E_{\mathrm{Vis}}(\ell)\right]\)</span>来表达。因此，通过衡量两种模型间的体积差，定义如下项： <spanclass="math display">\[E_{\mathrm{LoD}}(\ell)=\sum_{t \in T} v_{t} \mathbf{1}_{\left\{\ell_{t}\neq \ell_{t}^{\mathrm{Labatut}}\right\}}\]</span> 其中，<span class="math inline">\(t\)</span> 为四面体集合<span class="math inline">\(T\)</span> 中的一个四面体，<spanclass="math inline">\({1}_{\left\{\cdot\right\}}\)</span>为指示函数，<span class="math inline">\(\ell_{t_{1}}\)</span> 为四面体<span class="math inline">\(t\)</span> 的标签，<spanclass="math inline">\(v_{t}\)</span> 为四面体 <spanclass="math inline">\(t\)</span> 的体积。这一项与曼哈顿规则项相对:曼哈顿规则项删除任何平面都不支持的细节，这一项允许控制控制要删除的细节数量。</p></li><li><p>Plane Intersection Artifacts Removal</p><p>多数情况下，以上两项就够了，但是人工建筑可能会引起近平面的相交，多沿着场景中的锐边(像建筑物的轮廓)。噪声可能会导致Cell中包含unary cost投票为inside，但是实际上为outside的情况。为了避免这种人造建筑，我们在平面相交处的附近降低了unary和 pairwisecost的影响。对于每个四面体，如果其中心点与平面相交处的距离小于<spanclass="math inline">\(3d_{inlier}\)</span> ，则将其代价按以下公式更新：<span class="math display">\[E(t)=E_{\text {orig }}(t)\left(1-\exp \left(\frac{-d^{2}}{3 d_{\text{inlier }}^{2}}\right)\right)\]</span> 其中，<span class="math inline">\(E_{\text {orig}}(t)\)</span> 为原始四面体的代价。</p></li></ul><h2 id="结果">结果</h2><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210325170355.png" style="zoom: 80%;"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210325170420.png" style="zoom: 85%;"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210325170645.png" style="zoom: 82%;"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210325170749.png" style="zoom: 80%;"/></center><h2 id="参考文献">参考文献</h2><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Holzmann T, Oswald M R, Pollefeys M,et al. Plane-based surface regularization for urban 3dconstruction[C]//Proceedings 28th British Machine Vision Conference,2017 (BMVC). 2017: 1-9.<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Patrick Labatut, Jean-Philippe Pons,and Renaud Keriven. Robust and efficient surface reconstruction fromrange data. Computer Graphics Forum, pages 2275–2290, December 2009.<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>Dorin Comaniciu and Peter Meer. Meanshift: A robust approach toward feature space analysis. IEEETransactions on Pattern Analysis and Machine Intelligence,24(5):603–619, 2002.<a href="#fnref3" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p>Florent Lafarge and Pierre Alliez.Surface reconstruction through point set structuring. Comput. Graph.Forum, 32(2):225–234, 2013.<a href="#fnref4" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn5" role="doc-endnote"><p>Patrick Labatut, Jean-Philippe Pons,and Renaud Keriven. Efficient multi-view reconstruction of large-scalescenes using interest points, delaunay triangulation and graph cuts. InProceedings International Conference on Computer Vision, 2007.<ahref="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6" role="doc-endnote"><p>Holzmann T, Oswald M R, Pollefeys M,et al. Plane-based surface regularization for urban 3dconstruction[C]//Proceedings 28th British Machine Vision Conference,2017 (BMVC). 2017: 1-9.<a href="#fnref6" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn7" role="doc-endnote"><p>Florent Lafarge, Renaud Keriven,Mathieu Brédif, and Hoang-Hiep Vu. A hybrid multiview stereo algorithmfor modeling urban scenes. IEEE Trans. Pattern Anal. Mach. Intell.,35(1):5–17, 2013.<a href="#fnref7" class="footnote-back"role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 文献研读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mesh </tag>
            
            <tag> 规则化 </tag>
            
            <tag> 平面感知 </tag>
            
            <tag> 曼哈顿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构感知的建筑Mesh网多边形化(2020)</title>
      <link href="/posts/76ec7bf1.html"/>
      <url>/posts/76ec7bf1.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>提出了一个新的Mesh网多边形化(Polygonization)方法，其最主要的特点是结构感知(structureawareness)，即保留原始网基元的邻接关系。源码地址：<ahref="https://github.com/VasileiosBouzas/MeshPolygonization">MeshPolygonization</a></p><span id="more"></span><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/20210804093756.png" style="zoom: 80%;" /></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo@master/img/20210408114254.png" style="zoom: 80%;" /></center><h2 id="贡献">贡献</h2><ul><li><p>一种基于平面区域生长的Mesh网分割方法</p><p>(A novel mesh segmentation technique based on region growing for thedetection of planar components in surface meshes)</p></li><li><p>一种基于优化的Mesh网简化方法</p><p>(An optimization-based method for the construction of the simplifiedsurface models based on the definition of sharp features through abuilding scaffold and of faces through 2D arrangements)</p></li></ul><h2 id="相关工作">相关工作</h2><ul><li><strong>Mesh网简化/多边形化 Meshsimplification/polygonization</strong><ol type="1"><li>Quadric Error metrics (QEM) (1997) <a href="#fn2"class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a></li><li>Structure-Aware Mesh Decimation (SAMD) (2015) <a href="#fn3"class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a></li><li>Variational Shape Approximation (VSA) (2004) <a href="#fn4"class="footnote-ref" id="fnref4"role="doc-noteref"><sup>4</sup></a></li></ol></li><li><strong>结构感知 Structure awareness</strong>结构：<strong><em>parts &amp; interrelationships</em></strong><ul><li>the <strong><em>parts</em></strong> composing the object</li><li>the <strong><em>interrelationships</em></strong> between theseobject parts</li></ul></li></ul><h2 id="方法概述">方法概述</h2><ol type="1"><li>基于网分割的基元探测</li><li>将基元之间的邻接关系编码成图</li><li>多边形化</li></ol><h3 id="分割segmentation">分割(Segmentation)</h3><p>基于平面检测(Planar detect)</p><ol type="1"><li>对Mesh的每个顶点计算k-ring邻域的平面度，每个面的平面度为三个顶点的均值</li><li>将平面度最高的面作为种子面，得到第一块平面区域，收集其k-ring邻域，通过主成分分析(PCA)定义一个参考平面</li><li>检测种子点的k-ring邻域面，只要它们的顶点与参考平面的距离小于阈值，就在该区域添加面</li><li>重复上述过程，直到整个Mesh网被分为不同的平面区域</li></ol><p>这些分割后的平面区域(<strong><em>segments</em></strong> or<strong><em>primitives</em></strong>)，其数量通常会过多，为了减少其数量，进行<strong><em>refinement</em></strong>，与Nanand Wonka (2017)<a href="#fn5" class="footnote-ref" id="fnref5"role="doc-noteref"><sup>5</sup></a>中的类似。</p><h3 id="结构图structure-graph">结构图(Structure graph)</h3><p>寻找segments之间的相互关系，将其编码成无向图(structuregraph)，就像SAMD<a href="#fn6" class="footnote-ref" id="fnref6"role="doc-noteref"><sup>6</sup></a>中的graph of proxies。</p><p>目的：</p><ul><li>根据原始模型的结构，确定简化网格的组件及其在三维空间中的配置。这样，能够保证了我们的方法的结果接近于初始模型</li><li>仅表示恢复简化Mesh边缘所需的成对intersections，而不是全部计算。因此，与传统的平面装配方法如Polyfit<ahref="#fn7" class="footnote-ref" id="fnref7"role="doc-noteref"><sup>7</sup></a>相比，计算复杂度大大降低</li></ul><p>尽管分割后进行了refinement，但是有些segments仍然不能用于下一步的多边形化。因此，我们为每个segment赋予<strong><em>importancevalue</em></strong>，其值为 <spanclass="math inline">\(Area(\text{segment})/Area(\text{entire meshsurface})\)</span>。之后构建结构图，如果两个primitive共享至少一个顶点，则认为这两个primitive相邻(<strong><em>adjacency</em></strong>)。</p><h3 id="多边形化ploygonization">多边形化(Ploygonization)</h3><p>三个阶段</p><ol type="1"><li>构建建筑脚手架(<strong><em>building scaffold</em></strong>)</li><li>生成候选面(<strong><em>candidate faces</em></strong>)</li><li>通过优化选择候选面建立简化后模型(<strong><em>optimization</em></strong>)</li></ol><h4 id="building-scaffold">Building scaffold</h4><p>与 Variational Shape Approximation (VSA)<a href="#fn8"class="footnote-ref" id="fnref8"role="doc-noteref"><sup>8</sup></a>相似，我们的方法也是同通过一系列的代理平面(<strong><em>proxies</em></strong>)来近似原始模型，每个proxy对应一个primitive。我们通过buildingscaffold来定义proxies的边界，所谓的scaffold是由原始网上的所有<strong><em>sharpfeature</em></strong>组成的(Fig.5)。</p><p>sharp feature 的两种类型</p><ul><li><p><em>corners</em></p><p>三个primitive相邻</p></li><li><p><em>non-planar edges</em></p><p>非平面边</p></li></ul><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210318145706.png" style="zoom: 80%;" /></center><h4 id="candidate-faces">Candidate faces</h4><p>有了buildingscaffold后，我们首先用线框网(只有边和点)来近似原始网。同时以下述过程定义<strong><em>candidatefaces</em></strong>:</p><ul><li><p>对于每个平面区域，收集所有的scaffoldedge，将其投影在该区域的支持平面上</p></li><li><p>这些边的投影组成了一个二维排列(Fig.6)，这个二维排列的面，作为该平面区域的候选面</p></li></ul><p>由于分割可能会出现错误，还需要进行优化才能得到最终的简化网。注意，这种通过buildingscaffold生成candidate faces的方法有别于Polyfit<a href="#fn9"class="footnote-ref" id="fnref9"role="doc-noteref"><sup>9</sup></a>中所有面相交的方法，大大减少了候选面的数量，提高了后续的解算速度。</p><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210318145259.png" style="zoom: 80%;" /></center><h4 id="optimization">Optimization</h4><p>优化过程参考(Nan and Wonka, 2017)<a href="#fn10" class="footnote-ref"id="fnref10"role="doc-noteref"><sup>10</sup></a>，这种优化基于二元线性规划问题(binarylinear programming problem)<a href="#fn11" class="footnote-ref"id="fnref11" role="doc-noteref"><sup>11</sup></a><a href="#fn12"class="footnote-ref" id="fnref12"role="doc-noteref"><sup>12</sup></a>。对于这种问题，每个未知量<spanclass="math inline">\(x_{i}\)</span>都用0或1来表示，就本文而言即代表候选面被选择或未被选择。</p><p>问题构建</p><ol type="1"><li>最符合重建目标的能量函数</li><li>约束函数，以保证最终Mesh网的流形(<strong><em>manifold</em></strong>)和水密性(<strong><em>watertight</em></strong>)</li></ol><p>目标函数有三个能量项</p><ol type="1"><li><p><em>face coverage</em></p><p>该项与候选面中原始网覆盖的的面积有关(Fig.8)，优先选择原始网覆盖面积高的候选面。<span class="math display">\[E_{c}=\frac{1}{A(M)} \sum_{i=1}^{N} x_{i}\cdot\left(A\left(f_{i}\right)-A\left(M_{i}^{a}\right)\right)\]</span></p><p><span class="math inline">\(A(M)\)</span>为简化面<spanclass="math inline">\(M\)</span>的总表面积，<spanclass="math inline">\(A(f_i)\)</span>为候选面<spanclass="math inline">\(f_i\)</span>的面积，<spanclass="math inline">\(A\left(M_{i}^{a}\right)\)</span>为被原始网覆盖的面积，由于<spanclass="math inline">\(A(M)\)</span>是不可能已知的，所以我们用原始网<em>boundingbox</em>的表面积来代替，即<span class="math inline">\(A(M)\approxA(bbox)\)</span>。</p><center><p><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210318152725.png" style="zoom: 80%;"/></p></center></li><li><p><em>data fitting</em></p><p>除了考虑原始网覆盖的面积，我们还考虑原始网覆盖的面个数，优先选择原始网覆盖面个数多的候选面。<span class="math display">\[E_{f}=1-\frac{1}{|F|} \sum_{i=1}^{N} x_{i} \cdot s\left(f_{i}\right)\]</span> <spanclass="math inline">\(|F|\)</span>为原始网面总个数，<spanclass="math inline">\(s(f_i)\)</span>为候选面中被原始网覆盖的面个数。</p></li><li><p><em>model complexity</em></p><p>定义与锐边个数相关的模型复杂度，优先考虑co-planaredge而不是non-planar edge。 <span class="math display">\[E_{m}=\frac{1}{|E|} \sum_{i=1}^{|E|} c\left(e_{i}\right)\]</span></p><p><span class="math inline">\(|E|\)</span>为代理网中的总边数，<spanclass="math inline">\(c(e_i)\)</span>为指示函数，如果面是co-planar的，值取0，否则，即该边为锐边，其值取1。</p></li></ol><p>目标函数完全体 <span class="math display">\[\begin{array}{l}\min\limits_{x} \lambda_{f} \cdot E_{f}+\lambda_{c} \cdotE_{c}+\lambda_{m} \cdot E_{m} \\\text { s.t. }\left\{\begin{array}{c}\sum\limits_{j \in N\left(e_{i}\right)} x_{j}=2 \text { or } 0, &amp; 1\leq i \leq|E| \\x_{i} \in\{0,1\}, &amp; 1 \leq i \leq N\end{array}\right.\end{array}\]</span></p><ul><li>通过最小化该目标函数，可以产生一个拓扑有效的简化网。</li><li>分割取三环邻域</li><li>距离阈值与建筑物部件的最小宽度以及尺度有关</li><li>能量函数权重设置参照<a href="#fn13" class="footnote-ref"id="fnref13" role="doc-noteref"><sup>13</sup></a>，<spanclass="math inline">\(\lambda_{f}=0.43\)</span>, <spanclass="math inline">\(\lambda_{c}=0.27\)</span>, and <spanclass="math inline">\(\lambda_{m}=0.30\)</span>。</li></ul><h2 id="结果">结果</h2><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210319101712.png" style="zoom: 70%;"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210319101801.png" style="zoom: 80%;"/></center><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210319101523.png" style="zoom: 80%;"/></center><h2 id="参考文献">参考文献</h2><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Bouzas V, Ledoux H, Nan L.Structure-aware Building Mesh Polygonization[J]. ISPRS Journal ofPhotogrammetry and Remote Sensing, 2020, 167: 432-442.<a href="#fnref1"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Garland M, Heckbert P S. Surfacesimplification using quadric error metrics[C]//Proceedings of the 24thannual conference on Computer graphics and interactive techniques. 1997:209-216.<a href="#fnref2" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>Salinas D, Lafarge F, Alliez P.Structure‐aware mesh decimation[C]//Computer Graphics Forum. 2015,34(6): 211-227.<a href="#fnref3" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p>Cohen-Steiner D, Alliez P, Desbrun M.Variational shape approximation[M]//ACM SIGGRAPH 2004 Papers. 2004:905-914.<a href="#fnref4" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn5" role="doc-endnote"><p>Nan L, Wonka P. Polyfit: Polygonalsurface reconstruction from point clouds[C]//Proceedings of the IEEEInternational Conference on Computer Vision. 2017: 2353-2361.<ahref="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6" role="doc-endnote"><p>Salinas D, Lafarge F, Alliez P.Structure‐aware mesh decimation[C]//Computer Graphics Forum. 2015,34(6): 211-227.<a href="#fnref6" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn7" role="doc-endnote"><p>Nan L, Wonka P. Polyfit: Polygonalsurface reconstruction from point clouds[C]//Proceedings of the IEEEInternational Conference on Computer Vision. 2017: 2353-2361.<ahref="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8" role="doc-endnote"><p>Cohen-Steiner D, Alliez P, Desbrun M.Variational shape approximation[M]//ACM SIGGRAPH 2004 Papers. 2004:905-914.<a href="#fnref8" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn9" role="doc-endnote"><p>Nan L, Wonka P. Polyfit: Polygonalsurface reconstruction from point clouds[C]//Proceedings of the IEEEInternational Conference on Computer Vision. 2017: 2353-2361.<ahref="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10" role="doc-endnote"><p>Nan L, Wonka P. Polyfit: Polygonalsurface reconstruction from point clouds[C]//Proceedings of the IEEEInternational Conference on Computer Vision. 2017: 2353-2361.<ahref="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11" role="doc-endnote"><p>Papadimitriou C H, Steiglitz K.Combinatorial optimization: algorithms and complexity[M]. CourierCorporation, 1998.<a href="#fnref11" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn12" role="doc-endnote"><p>Williams H P. Integerprogramming[M]//Logic and Integer Programming. Springer, Boston, MA,2009: 25-70.<a href="#fnref12" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn13" role="doc-endnote"><p>Nan L, Wonka P. Polyfit: Polygonalsurface reconstruction from point clouds[C]//Proceedings of the IEEEInternational Conference on Computer Vision. 2017: 2353-2361.<ahref="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 文献研读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mesh </tag>
            
            <tag> 多边形化 </tag>
            
            <tag> 结构感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++使用Matplotlib画图</title>
      <link href="/posts/c6338439.html"/>
      <url>/posts/c6338439.html</url>
      
        <content type="html"><![CDATA[<h2 id="matplotlib-cpp">Matplotlib-Cpp</h2><p>它可能是最简单的C++绘图库，本质上是调用了Python的Matplotlib绘图，用法和Matplotlib类似，详见其Github。<span id="more"></span></p><p>该项目的Gitbhub地址：<ahref="https://github.com/lava/matplotlib-cpp">matplotlib-cpp</a></p><h2 id="small-issue-to-fix">Small issue to fix</h2><p>win10+vs2019+python3.8 环境，使用前请参考<ahref="https://github.com/lava/matplotlib-cpp/issues/220">here</a>，修改一下<code>matplotlibcpp.h</code>中的”bug“，同时注意将项目使用的C++版本改为C++17。</p><h2 id="configuration">Configuration</h2><p>附加包含目录：</p><ul><li><code>D:\Programs\anaconda3\include</code></li><li><code>D:\Programs\anaconda3\Lib\site-packages\numpy\core\include</code></li></ul><p>链接器输入：</p><ul><li><code>D:\Programs\anaconda3\libs\python38.lib</code></li></ul><p>环境变量：</p><ul><li><p><code>PYTHONHOME</code> -&gt;<code>D:\Programs\anaconda3</code></p></li><li><p><code>PYTHONPATH</code> -&gt;<code>D:\Programs\anaconda3\Lib\site-packages</code></p></li></ul><h2 id="example">Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;matplotlibcpp.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> plt = matplotlibcpp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_chart_matplotlib</span><span class="params">(vector&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">clusters</span>(num_cluster);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pt : points)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cID = pt.<span class="built_in">get_cluster_id</span>();</span><br><span class="line">        clusters[cID].<span class="built_in">emplace_back</span>(pt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; clu : clusters)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt;x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pt : clu)</span><br><span class="line">        &#123;</span><br><span class="line">            x.<span class="built_in">emplace_back</span>(pt.<span class="built_in">get_x_coord</span>());</span><br><span class="line">            y.<span class="built_in">emplace_back</span>(pt.<span class="built_in">get_y_coord</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        plt::<span class="built_in">scatter</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    plt::<span class="built_in">axis</span>(<span class="string">&quot;equal&quot;</span>);</span><br><span class="line">    plt::<span class="built_in">title</span>(<span class="string">&quot;K-Means&quot;</span>);</span><br><span class="line">    plt::<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210316175828.png" style="zoom: 80%;" /><div>Example 1</div></center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;matplotlibcpp.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> plt = matplotlibcpp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowRectangle</span><span class="params">(WshRectangle&amp; rect, std::vector&lt;Vector2&lt;<span class="keyword">float</span>&gt;&gt;&amp; mVertices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">double</span>&gt; x, y;</span><br><span class="line">    std::vector&lt;<span class="keyword">double</span>&gt; b_x, b_y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : mVertices)</span><br><span class="line">    &#123;</span><br><span class="line">        x.<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        y.<span class="built_in">emplace_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    b_x.<span class="built_in">emplace_back</span>(rect.A.<span class="built_in">x</span>());</span><br><span class="line">    b_x.<span class="built_in">emplace_back</span>(rect.B.<span class="built_in">x</span>());</span><br><span class="line">    b_x.<span class="built_in">emplace_back</span>(rect.C.<span class="built_in">x</span>());</span><br><span class="line">    b_x.<span class="built_in">emplace_back</span>(rect.D.<span class="built_in">x</span>());</span><br><span class="line">    b_x.<span class="built_in">emplace_back</span>(rect.A.<span class="built_in">x</span>());</span><br><span class="line"></span><br><span class="line">    b_y.<span class="built_in">emplace_back</span>(rect.A.<span class="built_in">y</span>());</span><br><span class="line">    b_y.<span class="built_in">emplace_back</span>(rect.B.<span class="built_in">y</span>());</span><br><span class="line">    b_y.<span class="built_in">emplace_back</span>(rect.C.<span class="built_in">y</span>());</span><br><span class="line">    b_y.<span class="built_in">emplace_back</span>(rect.D.<span class="built_in">y</span>());</span><br><span class="line">    b_y.<span class="built_in">emplace_back</span>(rect.A.<span class="built_in">y</span>());</span><br><span class="line"></span><br><span class="line">    plt::<span class="built_in">scatter</span>(x, y);</span><br><span class="line"></span><br><span class="line">    plt::<span class="built_in">plot</span>(b_x, b_y, <span class="string">&quot;r-&quot;</span>);</span><br><span class="line">    plt::<span class="built_in">xlim</span>(<span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line">    plt::<span class="built_in">ylim</span>(<span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line">    plt::<span class="built_in">axis</span>(<span class="string">&quot;equal&quot;</span>);</span><br><span class="line">    plt::<span class="built_in">title</span>(<span class="string">&quot;Minimum Bounding Box&quot;</span>);</span><br><span class="line">    plt::<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210316200211.png" style="zoom: 80%;" /><div>Example 2</div></center>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维重建流程(AilceVision)</title>
      <link href="/posts/dd277f8c.html"/>
      <url>/posts/dd277f8c.html</url>
      
        <content type="html"><![CDATA[<div class="note info">            <p>From <a href="https://alicevision.org/#photogrammetr">AliceVision</a>.</p>          </div><h2 id="natural-feature-extraction">NATURAL FEATURE EXTRACTION</h2><p>The objective of this step is to extract distinctive groups of pixelsthat are, to some extent, invariant to changing camera viewpoints duringimage acquisition. Hence, a feature in the scene should have similarfeature descriptions in all images.</p><span id="more"></span><p>The most well-know feature detection method is the SIFT(Scale-invariant feature transform) algorithm. The initial goal of SIFTis to extract discriminative patches in a first image that can becompared to discriminative patches of a second image irrespective ofrotation, translation, and scale. As a relevant detail only exists at acertain scale, the extracted patches are centered at stable points ofinterest. The key idea is that, to some extent, one can use the SIFTinvariance to deal with the image transformations occurring when theviewpoints are changing during image acquisition.</p><p>From the representation of one image at different scales, which istechnically done by computing a pyramid of downscaled images. SIFTcomputes scale-space maxima of the Laplacian representation, which is aspecific image energy-based representation of the image, using so-calleddifferences of Gaussians. These maxima correspond to points of interest.It then samples for each one of these maxima a square image patch whoseorigin is the maximum and x-direction is the dominant gradient at theorigin. For each keypoint, a description of these patches isassociated.</p><p>The description, which is typically stored in 128 bits, consists of astatistics of gradients computed in regions around the keypoint. Theregion size is determined by the keypoint scale and the orientation isdetermined by the dominant axis.</p><p>As the number of extracted features may vary a lot due to thevariability of textures complexity (from one image to another or indifferent parts of the image), a post-filtering step is used to controlthe number of extracted features to reasonable limits (for instancebetween one and ten thousands per image). We use a grid filtering toensure a good repartition in the image.</p><h2 id="image-matching">IMAGE MATCHING</h2><p>The objective of this part is to find images that are looking to thesame areas of the scene. For that, we use the image retrieval techniquesto find images that share some content without the cost of resolving allfeature matches in details. The ambition is to simplify the image in acompact image descriptor which allows to compute the distance betweenall images descriptors efficiently.</p><p>One of the most common method to generate this image descriptor isthe vocabulary tree approach. By passing all extracted featuresdescriptors into it, it makes a classification by comparing theirdescriptors to the ones on each node of this tree. Each featuredescriptor ends up in one leaf, which can be stored by a simple index:the index of this leaf in the tree. The image descriptor is thenrepresented by this collection of used leaves indices.</p><p>It is now possible to see if different images share the same contentby comparing these image descriptors.</p><h2 id="features-matching">FEATURES MATCHING</h2><p>The objective of this step is to match all features between candidateimage pairs.</p><p>First, we perform photometric matches between the set of descriptorsfrom the 2 input images. For each feature in image A, we obtain a listof candidate features in image B. As the descriptor space is not alinear and well defined space, we cannot rely on absolute distancevalues to know if the match is valid or not (we can only have anabsolute higher bound distance). To remove bad candidates, we assumethat there’s only one valid match in the other image. So for eachfeature descriptor on the first image, we look for the 2 closestdescriptors and we use a relative threshold between them. Thisassumption will kill features on repetitive structure but has proved tobe a robust criterion [Lowe2004]. This provide a list of featurematching candidates based only on a photometric criterion. Find the 2closest descriptors in the second image for each feature iscomputationally intensive with a brute force approach, but manyoptimized algorithms exists. The most common one is Approximate NearestNeighbor, but there are alternatives like, Cascading Hashing.</p><p>Then, we use the features positions in the images to make a geometricfiltering by using epipolar geometry in an outlier detection frameworkcalled RANSAC (RANdom SAmple Consensus). We randomly select a small setof feature correspondences and compute the fundamental (or essential)matrix, then we check the number of features that validates this modeland iterate through the RANSAC framework.</p><h2 id="structure-from-motion">STRUCTURE FROM MOTION</h2><p>The objective of this step is to understand the geometricrelationship behind all the observations provided by the input images,and infer the rigid scene structure (3D points) with the pose (positionand orientation) and internal calibration of all cameras. TheIncremental pipeline is a growing reconstruction process. It firstcomputes an initial two-view reconstruction that is iteratively extendedby adding new views.</p><iframe width="100%" height="450" src="https://sketchfab.com/models/31c093dca5a84057983d8de22a96b416/embed" frameborder="0" allowvr allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true" onmousewheel style="box-sizing: border-box;"></iframe><p>First, it fuses all feature matches between image pairs into tracks.Each track is supposed to represent a point in space, visible frommultiple cameras. However, at this step of the pipeline, it stillcontains many outliers. During this fusion of matches, we removeincoherent tracks.</p><p>Then, the incremental algorithm has to choose the best initial imagepair. This choice is critical for the quality of the finalreconstruction. It should indeed provide robust matches and containreliable geometric information. So, this image pair should maximize thenumber of matches and the repartition of the corresponding features ineach image. But at the same time, the angle between the cameras shouldalso be large enough to provide reliable geometric information.</p><p>Then we compute the fundamental matrix between these 2 images andconsider that the first one is the origin of the coordinate system. Nowthat we know the pose of the 2 first cameras, we can triangulate thecorresponding 2D features into 3D points.</p><p>After that, we select all the images that have enough associationswith the features that are already reconstructed in 3D. This algorithmis called next best views selection. Based on these 2D-3D associationsit performs the resectioning of each of these new cameras. Theresectioning is a Perspective-n-Point algorithm (PnP) in a RANSACframework to find the pose of the camera that validates most of thefeatures associations. On each camera, a non-linear minimization isperformed to refine the pose.</p><p>From these new cameras poses, some tracks become visible by 2 or moreresected cameras and it triangulates them. Then, we launch a BundleAdjustment to refine everything: extrinsics and intrinsics parameters ofall cameras as well as the position of all 3D points. We filter theresults of the Bundle Adjustment by removing all observations that havehigh reprojection error or insufficient angles between observations.</p><p>As we have triangulated new points, we get more image candidates fornext best views selection. We iterate like that, adding cameras andtriangulating new 2D features into 3D points and removing 3D points thatbecame invalidated, until we can’t localize new views.</p><p>Many other approaches exists like Global [Moulon2013], Hierarchical[Havlena2010], [Toldo2015] or multi-stage [Shah2014] approaches.</p><h2 id="depth-maps-estimation">DEPTH MAPS ESTIMATION</h2><p>For all cameras that have been resolved by SfM, we want to retrievethe depth value of each pixel. Many approaches exist, like BlockMatching, Semi-Global Matching (SGM) [Hirschmüller2005],[Hirschmüller2008] or ADCensus [Xing2011]. We will focus on the SGMmethod implemented in AliceVision.</p><p>For each image, we select the N best/closest cameras around. Weselect fronto-parallel planes based on the intersection of the opticalaxis with the pixels of the selected neighboring cameras. This creates avolume W, H, Z with many depth candidates per pixel. We estimate thesimilarity for all of them. The similarity is computed by the Zero MeanNormalized Cross-Correlation (ZNCC) of a small patch in the main imagereprojected into the other camera. This create a volume of similarities.For each neighboring image, we accumulate similarities into this volume.This volume is very noisy. We apply a filtering step along X and Y axeswhich accumulates local costs which drastically reduce the score ofisolated high values. We finally select the local minima and replace theselected plane index with the depth value stored into a depth map. Thisdepth map has banding artifacts as it is based on the original selectionof depth values. So a refine step is applied to get depth values withsub-pixel accuracy.</p><p>All these depth maps can be computed independently in parallel. Thenwe apply a filtering step to ensure consistency between multiplecameras. A compromise is chosen based on both similarity value and thenumber of coherent cameras to keep weakly supported surfaces withoutadding artefacts.</p><h2 id="meshing">MESHING</h2><p>The objective of this step is to create a dense geometric surfacerepresentation of the scene.</p><p>First, we fuse all the depth maps into a global octree wherecompatible depth values are merged into the octree cells.</p><p>We then perform a 3D Delaunay tetrahedralization. Then a complexvoting procedure is done to compute weights on cells and weights onfacets connecting the cells as explained in [Jancosek2011] and[Jancosek2014].</p><p>A Graph Cut Max-Flow [Boykov2004] is applied to optimally cut thevolume. This cut represents the extracted mesh surface. We filter badcells on the surface. We finally apply a Laplacian filtering on the meshto remove local artefacts.</p><p>At this point, the mesh can also be simplified to reduce unnecessaryvertices.</p><h2 id="texturing">TEXTURING</h2><p>The objective of this step is to texture the generated mesh.</p><iframe width="100%" height="450" src="https://sketchfab.com/models/0d38fbbf35ce44d085e2ec18368942df/embed" frameborder="0" allowvr allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true" onmousewheel style="box-sizing: border-box;"></iframe><p>If the mesh has no associated UV, it computes automatic UV maps.AliceVision implements a basic UV mapping approach to minimize thetexture space. The standard UV mapping approach is provided by[Levy2002].</p><p>For each triangle, we use the visibility information associated toeach vertex to retrieve the texture candidates. We filter the cameraswithout a good angle to the surface to favor fronto-parallel cameras andfinally average the pixel values. Instead of a naive averaging, we use ageneralization of the multi-band blending described in [Burt1983], so weaverage more views in the low frequencies than in the high frequencies.This approach is in the same spirit than [Baumberg2002] and[Allene2008].</p><h2 id="localization">LOCALIZATION</h2><p>Based on the SfM results, we can perform camera localization andretrieve the motion of an animated camera in the scene of the 3Dreconstruction.</p><h3 id="camera-calibration">CAMERA CALIBRATION</h3><p>The internal camera parameters can be calibrated from multiple viewsof a checkerboard. This allows to retrieve focal length, principal pointand distortion parameters. A detailed explanation is presented in[opencvCameraCalibration].</p><h3 id="single-camera-localization">SINGLE CAMERA LOCALIZATION</h3><p>We use the algorithm presented in image matching section to localizethe closest images in the SfM results. Then we perform feature matchingwith those images as well as with the N previous frames. Then wedirectly get 2D-3D associations, that are used to localize the camera.Finally, a global Bundle Adjustment is performed to refine the cameraparameters.</p><h3 id="rig-of-cameras">RIG OF CAMERAS</h3><p>If a rig of cameras is used, we can perform the rig calibration. Welocalize cameras individually on the whole sequence. Then we use allvalid poses to compute the relative poses between cameras of the rig andchoose the more stable value across the images. Then we initialize therig relative pose with this value and perform a global Bundle Adjustmenton all the cameras of the rig. When the rig is calibrated, we can use itto directly localize the rig pose from the synchronized multi-camerassystem with [Kneip2014] approaches.</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
            <tag> 摄影测量 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单影像增强</title>
      <link href="/posts/6fdca1fc.html"/>
      <url>/posts/6fdca1fc.html</url>
      
        <content type="html"><![CDATA[<h2 id="算法流程">算法流程</h2><ol type="1"><li>将RGB转为Lab色彩空间</li><li>取出L通道，归一化，得到L'</li><li>将L'做imgadjust，得到L"</li><li>将L"ab转为RGB色彩空间</li></ol><span id="more"></span><h2 id="lab色彩空间">Lab色彩空间</h2><p>Lab是由一个亮度通道（channel）和两个颜色通道组成的。在Lab颜色空间中，每个颜色用L、a、b三个数字表示，各个分量的含义是这样的：</p><ul><li>L 代表亮度</li><li>a 代表从绿色到红色的分量</li><li>b 代表从蓝色到黄色的分量</li></ul><h2 id="imgadjust">imgadjust:</h2><p>参数为(lowIn, highIn, gamma) img =[(img-lowIn)/(highIn-lowIn)]^gamma</p><h2 id="原理简述">原理简述</h2><p>如果不考虑gamma，让gamma=1，这种图像增强实际上就是把图像两端截掉一部分，也就是线性拉伸，只保留lowIn-hignIn之间的值，结果就是图像暗部更暗，亮部更亮，lowIn越大，hignIn越小，细节损失越多。gamma相当于把线性拉伸变成了非线性拉伸，想象一下指数函数（图像值已经归一化了），如果gamma大于1，其0-1的图像就变成了向下凹陷的曲线，也就是图像会整体变暗，反之，如果gamma小于1，其0-1的图像就变成了向上凸起的曲线，图像就会整体变亮。</p><h2 id="matlab实现">matlab实现</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img = imread(<span class="string">&#x27;sub.jpg&#x27;</span>);</span><br><span class="line"></span><br><span class="line">img_lab = rgb2lab(shadow);</span><br><span class="line"></span><br><span class="line"><span class="comment">%The values of luminosity span a range from 0 to 100. Scale the values to the range [0 1], which is the expected range of images with data type double.</span></span><br><span class="line">max_luminosity = <span class="number">100</span>;</span><br><span class="line">L = img_lab(:,:,<span class="number">1</span>)/max_luminosity;</span><br><span class="line"></span><br><span class="line"><span class="comment">%Perform the three types of contrast adjustment on the luminosity channel, and keep the a* and b* channels unchanged. Convert the images back to the RGB color space.</span></span><br><span class="line">img_imadjust = img_lab;</span><br><span class="line">img_imadjust(:,:,<span class="number">1</span>) = imadjust(L,[<span class="number">0.1</span>,<span class="number">0.9</span>],[],<span class="number">11</span>)*max_luminosity;</span><br><span class="line">img_imadjust = lab2rgb(img_imadjust);</span><br><span class="line"></span><br><span class="line"><span class="comment">%Display the original image and the three contrast adjusted images as a montage.</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);  imshow(img);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);  imshow(img_imadjust);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="c实现">C++实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span>  <span class="comment">//openCV 4.3.0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImgAdjust</span><span class="params">(cv::Mat&amp; img, <span class="keyword">const</span> <span class="keyword">double</span>&amp; m_lowIn, <span class="keyword">const</span> <span class="keyword">double</span>&amp; m_highIn, <span class="keyword">const</span> <span class="keyword">double</span>&amp; m_gamma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; img.rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span>* p = img.ptr&lt;<span class="keyword">double</span>&gt;(row);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; img.cols; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[col] &gt; m_highIn)</span><br><span class="line">            &#123;</span><br><span class="line">                p[col] = m_highIn;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p[col] &lt; m_lowIn)</span><br><span class="line">            &#123;</span><br><span class="line">                p[col] = m_lowIn;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p[col] = std::<span class="built_in">pow</span>(((p[col] - m_lowIn) / (m_highIn - m_lowIn)), m_gamma);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImgEnhance</span><span class="params">(cv::Mat&amp; inImg, cv::Mat&amp; outImg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat labImg, L;</span><br><span class="line">    <span class="built_in">cvtColor</span>(inImg, labImg, cv::COLOR_BGR2Lab);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">extractChannel</span>(labImg, L, <span class="number">0</span>);</span><br><span class="line">    L.<span class="built_in">convertTo</span>(L, CV_64FC1, <span class="number">1.0</span> / <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">ImgAdjust</span>(L, <span class="number">0.2</span>, <span class="number">0.8</span> ,<span class="number">1</span>);</span><br><span class="line">    L.<span class="built_in">convertTo</span>(L, CV_8UC1, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat in[] = &#123; L, labImg &#125;;</span><br><span class="line">    <span class="keyword">int</span> from_to[] = &#123; <span class="number">0</span>,<span class="number">0</span>, <span class="number">2</span>,<span class="number">1</span>, <span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">enhancedLab</span><span class="params">(inImg.rows, inImg.cols, CV_8UC3)</span></span>;</span><br><span class="line">    <span class="built_in">mixChannels</span>(in, <span class="number">2</span>, &amp;enhancedLab, <span class="number">1</span>, from_to, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cvtColor</span>(enhancedLab, outImg, cv::COLOR_Lab2BGR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat img, enhancedImg;</span><br><span class="line">    img = cv::<span class="built_in">imread</span>(<span class="string">&quot;DJI_0719.JPG&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ImgEnhance</span>(img, enhancedImg);</span><br><span class="line">    WIE1.<span class="built_in">Run</span>(img, enhancedImg1);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Before&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Before&quot;</span>, img);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Enhance&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Enhance&quot;</span>, enhancedImg);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效果">效果</h2><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326145106.png" width="500"/><div>原图</div></center><center><br><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326145136.png"  width="500" /><div>参数为0.2, 0.8, 1.2</div></center><center><br><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326144833.png" width="500" /><div>参数为0, 1, 0.5</div></center><center><br><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210326144944.png" width="500" /><div>参数为0, 1, 3</div></center>]]></content>
      
      
      <categories>
          
          <category> 算法仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 影像增强 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移植OpenMVG中求解GlobalT总结</title>
      <link href="/posts/51beaddf.html"/>
      <url>/posts/51beaddf.html</url>
      
        <content type="html"><![CDATA[<h2 id="整体流程">整体流程</h2><p>已知相对定向(Relative Motion)和全局角元素(GlobalRotation)求解全局线元素(Global Translation)</p><ol type="1"><li>将RO和GlobalR从摄影测量坐标系转至计算机视觉坐标系</li><li>通过相对定向结果列出所有的Triplets</li><li>使用边覆盖算法进行三三验证</li><li>使用通过验证的ROPerTriplet求解最终的GlobalT</li></ol><span id="more"></span><h2 id="遇到的问题">遇到的问题</h2><ol type="1"><li><p>平差失败</p><p>由于平差失败，观察点云发现相机位置疏密不均，讨论后的几个策略如下：</p><ul><li><p>重心化-&gt;不会产生太大的差异</p></li><li><p>GPS坐标引导全局线元素求解-&gt;讨论后未实现，讨论内容见附录</p></li><li><p>尺度一致性问题-&gt;解决问题</p></li></ul><p>在移植时对于OpenMVG求解中的尺度理解不够深，一味的拷贝导致求解的GlobalT不够精确，且很难找到原因，所以移植前一定要清楚每段代码的含义。</p></li><li><p>内存占用 VS 效率</p><p>如果内存占用超过物理内存大小，则一般会使用硬盘空间来进行内存交换，导致运行速度变慢。在GetTracksNum中，若使用vector则开启多线程后内存占用过高，若使用map则由于不支持随机访问，效率太低，尝试开源库phmap无果。最终，优化了数据结构，仍然使用vector，效率略低，但减少了很多内存开销。计算内存占用时，要考虑多线程的因素，比如若单线程需要开辟300M空间，听起来还不错，但若开启16线程，那么就需要大概4G的空间。</p></li><li><p>非正常数</p><p>即DenormalizedNumber，为形如4.57*e-312的一类非常接近于0的数。它会拖慢计算效率，通常CPU会自动将其转换为0，flushdenormal values to zero (FTZ), or treat denormal inputs as zero(DAZ)。</p></li><li><p>外部库Bug</p><p>将Release模式下的调试信息格式改成/Zi，链接器中的生成调试信息改成/DEBUG，此时程序崩溃生成的.dmp文件可以定位至Bug发生位置。由此怀疑Eigen中某个函数在处理#DEN类型的数据时出现Bug，更新Eigen后解决(有待进一步测试)。</p></li></ol><h2 id="解决的问题">解决的问题</h2><ol type="1"><li><p>离群值检测</p><p>开始尝试的思路是对所有点求解距离矩阵，之后基于距离矩阵检测离群值。后来发现这样效率很低，于是尝试找到能尽可能表达整个点云的一个点，用所有点到该代理点的距离来衡量离群程度。代理点的计算方法开始选择的是X、Y、Z的均值，但是由于存在异常点(坐标值过大，能以一己之力提高整个点云的均值)，于是决定用中值代替均值，更稳健但牺牲了一些效率，详细的离群值检测方法见下文。</p></li><li><p>三维相似变换验证替代线性规划求解</p><p>OpenMVG中对每个三三环的处理是完全舍弃相对定向线元素，重新利用线性规划的方法<ahref="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>求解线元素，精度很高但是效率太低。于是移植时将思路转换为验证相对定向线元素，验证通过则保留，验证失败则舍弃。具体验证的方法为：将点云IJ与点云JK、点云JK与点云IK分别做三维相似变换，记录残差小于阈值的点即SelectTracks，若残差小于阈值的点比例高于0.8则验证成功。</p></li><li><p>建立像点数组</p><p>在不改变原有的数据结构的情况下，实现通过像点ID快速访问影像ID，并且只占用单个线程的内存。</p></li></ol><h2 id="技巧">技巧</h2><ol type="1"><li><p>Cheirality</p><p>指真实世界中物点一定在相片的前面的性质，理论上可以根据此性质筛出在相片后面的飞点，但实际效果不好(有待进一步试验)。</p></li><li><p>openMP基本用法</p><p>注意：线程之间可以同时访问，但不能同时修改数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="function">std::vector&lt;RelativeMotion&gt; <span class="title">initial_estimates</span><span class="params">(omp_get_max_threads())</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">std::vector&lt;RelativeMotion&gt; <span class="title">initial_estimates</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _OPENMP</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _OPENMP</span></span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec_triplets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> thread_id = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> thread_id = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _OPENMP</span></span></span><br><span class="line">    </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp critical</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _OPENMP</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        m_mutexSet.<span class="built_in">insert</span>(&#123; triplet.i, triplet.j &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    initial_estimates[thread_id].<span class="built_in">emplace_back</span>(relative_motion);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>计时类写法</p><p>TimeCount.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeCount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">TimeCount</span>();</span><br><span class="line">     <span class="built_in">TimeCount</span>(std::string prompt);</span><br><span class="line">     ~<span class="built_in">TimeCount</span>();  </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">temp_end</span><span class="params">(std::string prompt)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> bEnd;</span><br><span class="line">    std::chrono::high_resolution_clock::time_point start_;</span><br><span class="line">    std::string promptStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TimeCount.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TimeCount.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line">TimeCount::<span class="built_in">TimeCount</span>()</span><br><span class="line">&#123;</span><br><span class="line">bEnd = <span class="literal">false</span>;</span><br><span class="line">promptStr = <span class="string">&quot;Elapsed: &quot;</span>;</span><br><span class="line">start_ = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimeCount::<span class="built_in">TimeCount</span>(std::string prompt)</span><br><span class="line">&#123;</span><br><span class="line">bEnd = <span class="literal">false</span>;</span><br><span class="line">promptStr = prompt;</span><br><span class="line">start_ = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeCount::end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bEnd == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> end_ = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">double</span> dTimer = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_ - start_).<span class="built_in">count</span>();</span><br><span class="line">dTimer /= <span class="number">1000000</span>;</span><br><span class="line">std::cout &lt;&lt; promptStr &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dTimer &lt;&lt; <span class="string">&quot; s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">bEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeCount::temp_end</span><span class="params">(std::string prompt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bEnd == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> end_ = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">double</span> dTimer = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_ - start_).<span class="built_in">count</span>();</span><br><span class="line">dTimer /= <span class="number">1000000</span>;</span><br><span class="line">std::cout &lt;&lt; prompt &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dTimer &lt;&lt; <span class="string">&quot; s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">start_ = end_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimeCount::~<span class="built_in">TimeCount</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bEnd == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> end_ = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">double</span> dTimer = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_ - start_).<span class="built_in">count</span>();</span><br><span class="line">dTimer /= <span class="number">1000000</span>;</span><br><span class="line">std::cout &lt;&lt; promptStr &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dTimer &lt;&lt; <span class="string">&quot; s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简易的控制台进度显示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> progress = (i * <span class="number">1.0</span>) / vec_triplets.<span class="built_in">size</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Progress: &quot;</span> &lt;&lt; progress * <span class="number">100</span> &lt;&lt; <span class="string">&quot;%\r&quot;</span>;</span><br><span class="line">std::cout.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lambda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ol><table><colgroup><col style="width: 15%" /><col style="width: 84%" /></colgroup><thead><tr class="header"><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>[]</td><td>不捕获任何外部变量</td></tr><tr class="even"><td>[变量名, …]</td><td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr class="odd"><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr class="even"><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr class="odd"><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr class="even"><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr class="odd"><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; cout &lt;&lt; ++a; &#125;; </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// Print: 123</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// Print: 124</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(vec_tripletCandidates.<span class="built_in">begin</span>(), vec_tripletCandidates.<span class="built_in">end</span>(),</span><br><span class="line">[](<span class="keyword">const</span> CandiTriplet &amp;a, <span class="keyword">const</span> CandiTriplet &amp;b) &#123;<span class="keyword">return</span> a.nTracks &gt; b.nTracks; &#125;);</span><br></pre></td></tr></table></figure></li><li><p>C++标准容器</p><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr class="header"><th style="text-align: left;">顺序容器</th><th style="text-align: left;">介绍</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">vector</td><tdstyle="text-align: left;">可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</td></tr><tr class="even"><td style="text-align: left;">deque</td><tdstyle="text-align: left;">双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td></tr><tr class="odd"><td style="text-align: left;">list</td><td style="text-align: left;">双向链表。只支持双向顺序访问。在 list中任何位置进行插入/删除操作速度都很快</td></tr><tr class="even"><td style="text-align: left;">forward_list</td><tdstyle="text-align: left;">单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</td></tr><tr class="odd"><td style="text-align: left;">array</td><tdstyle="text-align: left;">固定数组大小。支持快速随机访问。不能添加或删除元素</td></tr><tr class="even"><td style="text-align: left;">string</td><td style="text-align: left;">与 vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</td></tr></tbody></table><table><colgroup><col style="width: 24%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th style="text-align: left;">关联容器</th><th style="text-align: left;">介绍</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">map</td><td style="text-align: left;">一些 关键字-值对，关键字起到索引的作用，值则表示与索引相关联的数据</td></tr><tr class="even"><td style="text-align: left;">set</td><td style="text-align: left;">每个元素只包含一个关键字，set支持高效的关键词查询操作，检查一个给定关键字是否在 set 中</td></tr><tr class="odd"><td style="text-align: left;">multimap</td><td style="text-align: left;">允许重复关键字的map</td></tr><tr class="even"><td style="text-align: left;">multiset</td><td style="text-align: left;">允许重复关键字的set</td></tr><tr class="odd"><td style="text-align: left;">unordered_map</td><td style="text-align: left;">不保持关键字按顺序存储的map</td></tr><tr class="even"><td style="text-align: left;">unordered_set</td><td style="text-align: left;">不保持关键字按顺序存储的set</td></tr><tr class="odd"><td style="text-align: left;">unordered_multi_map</td><tdstyle="text-align: left;">是一个允许重复关键字，元素无序保存的map</td></tr><tr class="even"><td style="text-align: left;">unordered_multi_set</td><tdstyle="text-align: left;">是一个允许重复关键字，元素无序保存的set</td></tr></tbody></table></li><li><p>几种循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; vec_edges.<span class="built_in">size</span>(); ++k)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pair : vec_pair)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = objPt.<span class="built_in">begin</span>(); iter != objPt.<span class="built_in">end</span>(); ++iter)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测离群值</p><p>Matlab：</p><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>median</td><td>Returns <code>true</code> for elements more than three scaled MADfrom the median. The scaled MAD is defined as<code>c*median(abs(A-median(A)))</code>, where<code>c=-1/(sqrt(2)*erfcinv(3/2))</code>.</td></tr><tr class="even"><td>mean</td><td>Returns <code>true</code> for elements more than three standarddeviations from the mean. This method is faster but less robust than<code>median</code>.</td></tr><tr class="odd"><td>quartiles</td><td>Returns <code>true</code> for elements more than 1.5 interquartileranges above the upper quartile or below the lower quartile. This methodis useful when the data in <code>A</code> is not normallydistributed.</td></tr><tr class="even"><td>grubbs</td><td>Applies Grubbs’s test for outliers, which removes one outlier periteration based on hypothesis testing. This method assumes that the datain <code>A</code> is normally distributed.</td></tr><tr class="odd"><td>gesd</td><td>Applies the generalized extreme Studentized deviate test foroutliers. This iterative method is similar to <code>grubbs</code>, butcan perform better when there are multiple outliers masking eachother.</td></tr></tbody></table></li><li><p>内存计算</p><table><thead><tr class="header"><th>64bit环境</th><th>字节 Byte</th></tr></thead><tbody><tr class="odd"><td>char</td><td>1</td></tr><tr class="even"><td>short int</td><td>2</td></tr><tr class="odd"><td>int</td><td>4</td></tr><tr class="even"><td>unsigned int</td><td>4</td></tr><tr class="odd"><td>long</td><td>4</td></tr><tr class="even"><td>unsigned long</td><td>4</td></tr><tr class="odd"><td>long long</td><td>8</td></tr><tr class="even"><td>float</td><td>4</td></tr><tr class="odd"><td>double</td><td>8</td></tr></tbody></table><p>单位换算</p><p>1Byte=8bit；1KB=1024B；1MB=1024KB；1GB=1024MB；1TB=1024GB</p></li></ol><h2 id="算法">算法</h2><ol type="1"><li><p>对索引的部分排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartialSortIndexes</span><span class="params">(<span class="keyword">const</span> std::vector&lt;T&gt;&amp; v, std::vector&lt;<span class="keyword">uint32_t</span>&gt;&amp; idx, <span class="keyword">int</span>&amp; count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">idx.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//Use iota to assign 0~N to the vector idx</span></span><br><span class="line"><span class="built_in">iota</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Descending order partial sort compare with the value of v</span></span><br><span class="line">std::<span class="built_in">partial_sort</span>(std::<span class="built_in">begin</span>(idx), std::<span class="built_in">begin</span>(idx) + count, std::<span class="built_in">end</span>(idx),</span><br><span class="line">[&amp;v](<span class="keyword">uint32_t</span> i1, <span class="keyword">uint32_t</span> i2) &#123;<span class="keyword">return</span> v[i1] &gt; v[i2]; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>计算中值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CalculateMedian</span><span class="params">(std::vector&lt;<span class="keyword">double</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="keyword">double</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">std::<span class="built_in">advance</span>(iter, vec.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">std::<span class="built_in">nth_element</span>(std::<span class="built_in">begin</span>(vec), iter, std::<span class="built_in">end</span>(vec));</span><br><span class="line"><span class="keyword">double</span> median = vec[vec.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从vector去除指定索引元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One way</span></span><br><span class="line">std::<span class="built_in">sort</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>()); <span class="comment">// sort index array</span></span><br><span class="line">outliers.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>()), idx.<span class="built_in">end</span>());  <span class="comment">// remove duplicate index</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class ForwardIt, class SortUniqIndsFwdIt&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> ForwardIt <span class="title">remove_at</span><span class="params">(ForwardIt first, ForwardIt last, SortUniqIndsFwdIt ii_first, SortUniqIndsFwdIt ii_last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ii_first == ii_last) <span class="comment">// no indices-to-remove are given</span></span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIt&gt;::difference_type <span class="keyword">diff_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;SortUniqIndsFwdIt&gt;::value_type <span class="keyword">ind_t</span>;</span><br><span class="line">ForwardIt destination = first + <span class="keyword">static_cast</span>&lt;<span class="keyword">diff_t</span>&gt;(*ii_first);</span><br><span class="line"><span class="keyword">while</span> (ii_first != ii_last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// advance to an index after a chunk of elements-to-keep</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">ind_t</span> cur = *ii_first++; ii_first != ii_last; ++ii_first)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">ind_t</span> nxt = *ii_first;</span><br><span class="line"><span class="keyword">if</span> (nxt - cur &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">cur = nxt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// move the chunk of elements-to-keep to new destination</span></span><br><span class="line"><span class="keyword">const</span> ForwardIt source_first =</span><br><span class="line">first + <span class="keyword">static_cast</span>&lt;<span class="keyword">diff_t</span>&gt;(*(ii_first - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ForwardIt source_last =</span><br><span class="line">ii_first != ii_last ? first + <span class="keyword">static_cast</span>&lt;<span class="keyword">diff_t</span>&gt;(*ii_first) : last;</span><br><span class="line">std::<span class="built_in">move</span>(source_first, source_last, destination);</span><br><span class="line"><span class="comment">// std::copy(source_first, source_last, destination) // c++98 version</span></span><br><span class="line">destination += source_last - source_first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vecX.<span class="built_in">erase</span>(<span class="built_in">remove_at</span>(vecX.<span class="built_in">begin</span>(), vecX.<span class="built_in">end</span>(), idx.<span class="built_in">begin</span>(), idx.<span class="built_in">end</span>()), vecX.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Another Way</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = objPt.<span class="built_in">begin</span>(); iter != objPt.<span class="built_in">end</span>();)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (objPt.status == STATUS::REMOVE)</span><br><span class="line">&#123;</span><br><span class="line">iter = objPt.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++iter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="附录">附录</h2><p>2021-2-8 讨论内容</p><ol type="1"><li><p>三三环内<spanclass="math inline">\(Tab，Tbc，Tac\)</span>要统一尺度</p><ul><li><p><span class="math inline">\(T_a = [0,0,0]^T\)</span></p><p><span class="math inline">\(T_b = C_{ab}\)</span></p><p><span class="math inline">\(T_c = T_b + R_{ab} * C_{bc} *S\)</span></p></li><li><p><span class="math inline">\(T_{ab} =T_{ab}/||T_a-T_b||\)</span></p><p><span class="math inline">\(T_{bc} = T_{bc}/||T_b-T_c||\)</span></p><p><span class="math inline">\(T_{ac} =T_{ac}/||T_a-T_c||\)</span></p></li></ul></li><li><p>主光轴夹角计算问题 ？ 待讨论</p></li><li><p>实验在没加GPS的代码上做</p></li><li><p>尝试增加残差项 <span class="math display">\[||GPS_j-GPS_i|| = s\cdot ||(-R_j^T\cdot t_j)-(-R_i^T\cdot ti)||\]</span></p></li><li><p>关于GPS残差项的权重</p><ul><li>GPS项和IMG项之间的权重由于单位不统一难以确定，初步判断将权重 <spanclass="math inline">\(\lambda\)</span>设为未知量，将解求权重与解求线元素分两大部分来迭代计算，参考OptCuts</li><li>可以使用GPS的相片中的权重 <spanclass="math inline">\(\lambda_i\)</span>，初步考虑使用tacks数量来衡量，tracks越少，GPS项的权重越大，</li></ul></li><li><p>注意：openMVG使用了reIndex，用来将N个可用view的ID数组reIndex成0-N的连续数组。</p></li><li><p><del>关于旋转矩阵的左乘右乘和tij,暂时还没搞清楚</del></p><p>已经搞清楚了，见 <ahref="https://www.wukongblog.com/2021/04/02/%E7%9B%B8%E5%AF%B9%E5%AE%9A%E5%90%91%E4%B8%AD%E7%9A%84tij%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/">相对定向中的tij到底是什么</a></p></li></ol><h2 id="参考文献">参考文献</h2><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Kahl F, Hartley R. Multiple-ViewGeometry Under the $ L_{}$ Norm[J]. IEEE Transactions on PatternAnalysis and Machine Intelligence, 2008, 30(9): 1603-1617.<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影测量 </tag>
            
            <tag> 空三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACRANSAC(2012)</title>
      <link href="/posts/dbeaa008.html"/>
      <url>/posts/dbeaa008.html</url>
      
        <content type="html"><![CDATA[<h2 id="nfa计算公式">NFA计算公式</h2><p>NFA：Number of false alarm<a href="#fn1" class="footnote-ref"id="fnref1" role="doc-noteref"><sup>1</sup></a> <spanclass="math display">\[NFA=N_{\text {outcomes }}\left(n-N_{\text {sample}}\right)\left(\begin{array}{l}n \\k\end{array}\right)\left(\begin{array}{c}k \\N_{\text {sample }}\end{array}\right)\left(\epsilon_{k}^{d} \alpha_{0}\right)^{k-N_{\text{sample }}}\]</span></p><ul><li><span class="math inline">\(N_{\text {sample }}\)</span>：每次采样的点数</li><li><span class="math inline">\(N_{\text {outcomes}}\)</span>：每次采样能够得到的模型个数</li><li><span class="math inline">\(n\)</span>：所有点数<span id="more"></span></li><li><span class="math inline">\(k\)</span>：对于每个模型，假定有 <spanclass="math inline">\(k\)</span> 个内点，其范围为 <spanclass="math inline">\([N_{sample}+1,n]\)</span></li><li><spanclass="math inline">\(d\)</span>：维数，点到线的距离取1，点到点的距离取2</li><li><spanclass="math inline">\(\epsilon_{k}\)</span>：将残差列表升序排序后，第<span class="math inline">\(k\)</span>小的残差值，表示该点为内点或外点的阈值</li><li><spanclass="math inline">\(\alpha_{0}\)</span>：单个点误差不超过1(通常用pixel表示)的概率，取决于background model，假设为独立事件</li><li><span class="math inline">\(\epsilon_{k}^{d}\alpha_{0}\)</span>：单个点误差不超过 <spanclass="math inline">\(\epsilon_{k}\)</span>的概率，也即该点为内点的概率，假设为独立事件</li><li><span class="math inline">\(\tbinom{n}{k}\)</span>：即 <spanclass="math inline">\(C_{n}^{k}\)</span></li><li><span class="math inline">\(\tbinom{k}{N_{sample}}\)</span>：即<span class="math inline">\(C_{N_{sample}}^{k}\)</span></li></ul><h2 id="流程">流程</h2><ol type="1"><li>设置最大迭代次数 <span class="math inline">\(nIter\)</span>，<spanclass="math inline">\(NFA\)</span> 阈值，<spanclass="math inline">\(NFA_{min}^{total} = \infty\)</span></li><li>进行随机采样，每次采样 <span class="math inline">\(N_{\text {sample}}\)</span> 个点，建立 <span class="math inline">\(N_{\text {outcomes}}\)</span> 个模型</li><li>循环所有模型，用每个模型计算 <span class="math inline">\(n\)</span>个点的残差，将残差数组升序排列</li><li>对每个模型，按 <span class="math inline">\(k=N_{\text {sample}}-1;k&lt;n;k++\)</span> 迭代计算 <spanclass="math inline">\(NFA\)</span>，找到该模型中的 <spanclass="math inline">\(NFA_{min}^{model}\)</span> 及其对应的 <spanclass="math inline">\(k\)</span></li><li>如果该模型的 <span class="math inline">\(NFA_{min}^{model}\)</span>小于所有迭代的最小值 <spanclass="math inline">\(NFA_{min}^{total}\)</span>，记录此模型和内点下标数组(由<span class="math inline">\(k\)</span> 可知)</li><li>如果 <span class="math inline">\(NFA_{min}^{total}\)</span>小于设置的阈值，将当前最大迭代次数设置为 $0.1 * nIter$，为了保证迭代次数，本条只执行一次</li></ol><h2 id="参考文献">参考文献</h2><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Moisan L, Moulon P, Monasse P.Automatic homographic registration of a pair of images, with a contrarioelimination of outliers[J]. Image Processing On Line, 2012, 2: 56-73.<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 算法仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACRANSAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸优化(Convex Optimization)</title>
      <link href="/posts/cc3cbade.html"/>
      <url>/posts/cc3cbade.html</url>
      
        <content type="html"><![CDATA[<h2 id="特点">特点</h2><ul><li><p>优化问题的分水岭不是线性和非线性，而是凸性和非凸性。</p></li><li><p>凸优化问题的信息复杂度远远低于一般的非线性优化问题。</p></li><li><p>将实际问题建模为非线性优化问题是相当直接的。当建模完成后，局部优化的技巧体现在<strong>问题求解</strong>上。而凸优化的技巧和难点体现在<strong>描述问题</strong>的环节。</p><span id="more"></span></li></ul><h2 id="线性规划lp">线性规划(LP)</h2><h2 id="二次规划qp">二次规划(QP)</h2><h2 id="二次约束二次规划qcqp">二次约束二次规划(QCQP)</h2><h2 id="二阶锥规划socp">二阶锥规划(SOCP)</h2><h2 id="半定规划sdp">半定规划(SDP)</h2><h2 id="锥规划cp">锥规划(CP)</h2><center><img src="https://cdn.jsdelivr.net/gh/WuKongBlog/PicGo/img/20210306174802.png" style="zoom: 80%;" /><div>凸优化问题关系</div></center>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无穷范数下的多视几何(2008)</title>
      <link href="/posts/608d7221.html"/>
      <url>/posts/608d7221.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文<a href="#fn1" class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>提供了一个解决多视几何问题的<strong>无穷范数(<spanclass="math inline">\(L_\infty\)</span>)</strong>框架。在这个框架下，三角化、后方交会、H矩阵估计等一系列<strong>structure and motion问题</strong>可以被转化为一个<strong>拟凸优化(quasi-convexoptimization)</strong>问题。这种拟凸优化问题可以用<strong>二阶锥规划(Second-OrderCone Programming,SOCP)</strong>来高效求解。本文算法已经用不同维度的真实数据进行验证，表现优秀。</p><span id="more"></span><h2 id="引言">引言</h2><ul><li><p><strong>Structure and motion 问题</strong></p><p>给定影像数据，求解场景的structure(3D点坐标) 和/或相机的motion(位姿)，一般思路是最小化<strong>重投影误差</strong>。</p></li><li><p><strong>残差</strong></p><p>令 <span class="math inline">\(r\)</span> 为残差向量，则问题转化为：<span class="math display">\[minimize\ \ \left\|r\right\|\]</span> 在这种问题下，<span class="math inline">\(\left\| \cdot\right\|\)</span> 通常取 <span class="math inline">\(L_2\)</span>范数，本文研究了若用 <span class="math inline">\(L_\infty\)</span>范数替代 <span class="math inline">\(L_2\)</span>范数将会产生什么样的结果。</p></li><li><p><strong>贡献</strong></p><ul><li>引入 <span class="math inline">\(L_\infty\)</span>框架，为一系列的几何视觉问题提供了全局高效计算能力。</li><li>引入二阶锥规划(SOCP)，论述了SOCP如何用于一些重建问题，这种技术也许可以应用在计算机视觉的其他领域。</li></ul></li><li><p><strong><span class="math inline">\(L_2\)</span>范数</strong></p><p>用 <span class="math inline">\(L_2\)</span> 范数求解 structure andmotion是一个困难的<strong>非凸(non-convex)</strong>问题。尽管最近有一些对于非凸问题估计全局最值的有益尝试，这些算法还是受限于计算量过大，只能用于较小的维度。一般来说，这些方法依赖于局部迭代技术，也就是所谓的<em>bundleadjustment</em>，需要良好的初值去避免局部最小值。然而，一些初值获取的方法如八点法，利用代数方法优化了代价函数，虽然简化了问题，却没有几何或统计意义。当明显的噪声出现时，这些初值可能会距离全局最优值非常远。</p></li><li><p><strong><span class="math inline">\(L_\infty\)</span>范数</strong></p><p><span class="math inline">\(L_\infty\)</span> 范数方法介于 <spanclass="math inline">\(L_2\)</span>范数方法和线性算法之间。能够使用一个有几何意义的代价函数，确保获得全局最优值，同时对计算的需求较低。能使用这种方法解决的问题有：</p><ul><li>two-view triangulation problem</li><li>multiview triangulation problem</li><li>multiview structure and motion problem，assuming knownrotations</li><li>homography estimation and camera resectioning</li><li>multiview reconstruction knowing homographies induced by aplane</li><li>visual odometry (motion without structure)</li></ul><p><span class="math inline">\(L_\infty\)</span>范数可能存在的缺点是它可能对于离群值不够稳健。事实上，对于离群值的检测同样关键。</p></li></ul><h2 id="三角化问题">三角化问题</h2><p>以三角化问题(triangulation problem)为例，引入 <spanclass="math inline">\(L_\infty\)</span> 方法。</p><p>令 <span class="math inline">\(P_i\)</span> (<spanclass="math inline">\(i=1,...,m\)</span>) 为 <spanclass="math inline">\(m\)</span> 个已知相机矩阵，<spanclass="math inline">\(u_i\)</span> 为未知3D点 <spanclass="math inline">\(U\)</span>对应的像点，两者都用齐次坐标表示，则有： <span class="math display">\[u_i= P_iU\]</span></p><p>三角化问题即为，已知 <span class="math inline">\(P_i\)</span> 和<span class="math inline">\(u_i\)</span> 求解 <spanclass="math inline">\(U\)</span>。在没有噪声的情况下，求解 <spanclass="math inline">\(U\)</span>是很容易的，只需要找到光线的交点。但是当噪声出现时，同名光线不再一致，获得最佳的<span class="math inline">\(U\)</span>估计并非易事。正确的程序是，找到一个 <spanclass="math inline">\(U\)</span> 使得它的投影点最接近 <spanclass="math inline">\(u_i\)</span>，这里的“最接近”通常指的是在最小二乘的意义下的。因此，问题转化为： <spanclass="math display">\[\min_U \sum_{i=1}^{m}d(u_i,P_iU)^2\]</span> 上式中，<span class="math inline">\(d(\cdot,\cdot)\)</span>表示图像上两点的几何距离。在两张像片的情况下，<a href="#fn2"class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>中提出需要求解一个6次多项式；在三张像片的情况下，<ahref="#fn3" class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a>中提出需要求解一个47次的多项式。在更多像片的情况下，就没有必要再讨论这种方法了。</p><h3 id="代数方法algebraic-method">代数方法(Algebraic method)</h3><p>对于 <span class="math inline">\(m\)</span>张像片，可以用一种简单的代数方法解决这个问题。每个方程 <spanclass="math inline">\(u_i= P_iU\)</span>都有一个未知的缩放系数，这个方程可以更精确的写为： <spanclass="math display">\[k_iu_i=P_iU\]</span> 这是一个线性方程组，可以改写为如下形式： $$ </p><p>$$</p><p>这样就可以通过SVD分解等代数方法解决规模较大的问题。即使这种三角化的方法很吸引人，但他所最小化的代价函数是没有实际意义的，而且这种方法在一些情况下是不可靠的。</p><h3 id="中点法mid-point-method">中点法(Mid-point method)</h3><p>另一种方法是将所有同名像点反投影至物方，寻找一个最接近这些点的物方点<ahref="#fn4" class="footnote-ref" id="fnref4"role="doc-noteref"><sup>4</sup></a>。但这种方法在两条光线接近平行时表现很差。因此，无论是代数法还是中点法都不能很好的解决问题。</p><h3 id="多局部最小值multiple-local-minima">多局部最小值(Multiple LocalMinima)</h3><p>考虑 <span class="math inline">\(m-view\)</span> 的情况，用变量<spanclass="math inline">\(t\)</span>将<spanclass="math inline">\(U\)</span>参数化，认为一个变量点 <spanclass="math inline">\(\mathbf{U}(t)=\mathbf{U}_{0}+t\delta_{\mathbf{U}}\)</span> 沿着直线移动。则 <spanclass="math inline">\(t\)</span> “时刻”的代价函数为 <spanclass="math display">\[F(t)=\sum_{i=1}^{m} d\left(\mathbf{u}_{i}, \mathrm{P}_{i}\mathbf{U}(t)\right)^{2}=\sum_{i=1}^{m} f_{i}(t)^{2}\]</span> 其中 <span class="math inline">\(f_i(t)\)</span> 是与点在第<span class="math inline">\(i\)</span>幅图像中的投影相关的误差。对于t的值，U(t)位于摄像机前面，函数fi(t)的形式可以这样表示:当三维点沿着轨迹U(t)运动时，其像点在图像中沿直线单调地沿着一个恒定的方向运动(尽管速度不是恒定的)。随着t的变化，它会接近点ui，到达唯一的最接近的点，然后再次后退。在某一点，轨迹会穿过相机的焦平面，在这一点，<span class="math display">\[f_{i}(t)^{2}=\frac{(a+b t)^{2}+(c+d t)^{2}}{(e+g t)^{2}}\]</span> 该距离函数有一个最小值，当t = -d/e时为无穷大，当t→∞时渐近于(b2 + d2)/g2。</p><h3 id="正负性cheirality">正负性(Cheirality)</h3><p>Cheirality指的是我们考虑哪些点在摄像机前面，显然，目标物点 <spanclass="math inline">\(U\)</span>一定在摄像机之前。给定几个摄像机，所有摄像机前面的空间区域都是凸的，因为它被定义为一组由摄像机主平面包围的半空间的交集。根据上面给出的几何直觉，每个函数<spanclass="math inline">\(f_i(t)\)</span>必须对摄像机前面的点有一个最小值。因此，我们对这个代价函数作如下观察。</p><ul><li>对于<span class="math inline">\(U(t)\)</span>位于摄像机前的<spanclass="math inline">\(t\)</span>，<spanclass="math inline">\(f_i(t)\)</span>有一个最小值；但它却不是一个凸函数。</li></ul><p>如果每个 <span class="math inline">\(f_i(t)\)</span> 都是凸的，那么<span class="math inline">\(\sum_{i}f_i(t)\)</span> 也是一个凸函数。</p><p>因此，我们已经证明了三角化的最小二乘代价函数在任意一维横截面上都可能有多个最小值。</p><h2 id="拟凸函数">拟凸函数</h2><p>函数 <span class="math inline">\(f(x)\)</span> 的 <spanclass="math inline">\(\gamma\)</span> - 下水平集定义如下： <spanclass="math display">\[S_{\gamma}(f)=\{\mathrm{x} \in \operatorname{domain}(f) \midf(\mathrm{x}) \leq \gamma\}\]</span>考虑单个相机的三角化代价函数(3)的子水平集。从几何角度考虑，可以清楚地看出，映射到距离被测像点一定距离范围内的一点的空间点集形成了一个锥。假设一个圆盘在像平面上的半径为γ，圆锥体的顶点在摄像机的投影中心，并由这个圆在像平面上展开。只考虑锥的可见部分(在摄像机前)，一个重要的性质是锥是凸点集。一个定义在凸域上的函数，且其所有下水平集都是凸的，称为拟凸函数。</p><h3 id="拟凸函数最小值">拟凸函数最小值</h3><p>拟凸函数的一个重要性质是:拟凸函数的任何局部极小值也是全局极小值。因此，一个拟凸函数只有全局极小值，而所有的全局极小值都在一个凸集内，因此是连通集。</p><h3 id="拟凸函数集最大值">拟凸函数集最大值</h3><p>拟凸函数的和不是拟凸函数，因此不能期望有单个最小值。然而，拟凸函数集的最大值是拟凸的。即如果<span class="math inline">\(f_1(x),...,f_m(x)\)</span> 是拟凸函数，那么<span class="math inline">\(f_{max}(x)=max_i f_i(x)\)</span>也是拟凸函数。</p><h2 id="凸优化">凸优化</h2><h3 id="凸优化问题">凸优化问题</h3><p>凸优化问题的标准形式： <span class="math display">\[\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \min_x \ \ f_0(x) \\subject \ \ to\ \ f_i(x) \leq 0, \ i=1,...,m\]</span> 其中，<span class="math inline">\(f_0(x),f_i(x)\)</span>均为凸函数。</p><h3 id="二阶锥规划">二阶锥规划</h3><p>二阶锥规划的约束为： <span class="math display">\[\left\| A_ix+b_i \right\|_2 - (c_i^Tx+d_i)\leq0\]</span></p><h3 id="socp-可行性问题">SOCP 可行性问题</h3><p>可行性问题即寻找任何满足约束的 <span class="math inline">\(x\)</span>： <span class="math display">\[\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ find \ \ \ x\\subject \ \ to\  \  \ \left\| A_ix+b_i \right\|_2 - (c_i^Tx+d_i)\leq0\]</span> 这种问题很容易求解。</p><h3 id="socp-最小化最大值问题">SOCP 最小化最大值问题</h3><p>计算机视觉中的几何问题可能会写成如下形式： <spanclass="math display">\[\min_x \ \max_i \ \frac{\left\| A_ix+b_i \right\|_2}{c_i^Tx+d_i}\\subject\ \ to \ \ c_i^Tx+d_i \ge 0\]</span> 如果将 <span class="math inline">\({\left\| A_ix+b_i\right\|_2}/{c_i^Tx+d_i}\)</span>看作列向量中的一个元素，那这个问题就是最小化列向量的 $L_{} $范数。如果引入一个附加变量 <span class="math inline">\(\gamma\)</span>，问题可以被转化为如下形式： <span class="math display">\[\min_{\gamma,x} \ \gamma \ \ \ \subject\ \ to \ \ \frac{\left\| A_ix+b_i \right\|_2}{c_i^Tx+d_i} \le\gamma \   and\ \ c_i^Tx+d_i \ge 0\]</span> 在约束条件 <span class="math inline">\(c_i^Tx+d_i \ge0\)</span> 下， <span class="math inline">\({\left\| A_ix+b_i\right\|_2}/{c_i^Tx+d_i}\)</span> 是非凸的，甚至在 <spanclass="math inline">\(c_i^Tx+d_i = 0\)</span> 时， <spanclass="math inline">\({\left\| A_ix+b_i\right\|_2}/{c_i^Tx+d_i}\)</span>是未定义的。为了避免这种情况，将每个约束乘分母 ，得到： <spanclass="math display">\[\min_{\gamma,x} \ \gamma \ \ \ \subject\ \ to \ \ \ \left\| A_ix+b_i \right\|_2 - \gamma(c_i^Tx+d_i) \le0 \ and\ \ \gamma \ge 0\]</span> 对于一个固定的 <span class="math inline">\(\gamma \ge0\)</span> ，满足约束条件 $| A_ix+b_i |_2 - (c_i^Tx+d_i) $ 的 <spanclass="math inline">\(x\)</span>是一个凸集，因此，我们认为(12)是一个拟凸优化问题。</p><h3 id="二分法">二分法</h3><p>问题(14)看起来非常像标准的SOCP问题，但是如果同时将 <spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(\gamma\)</span> 作为变量，则约束 <spanclass="math inline">\(\left\| A_ix+b_i \right\|_2 - \gamma(c_i^Tx+d_i)\le 0\)</span> 是非凸的，如果固定 <spanclass="math inline">\(\gamma\)</span>则问题(14)为SOCP问题。求解思路：首先固定一个 <spanclass="math inline">\(\gamma_{rest}\)</span>,求解一个可行性问题，如果存在 <span class="math inline">\(x\)</span>对所有 <span class="math inline">\(i\)</span> 满足约束，则下个 <spanclass="math inline">\(\gamma\)</span> 小于 <spanclass="math inline">\(\gamma_{rest}\)</span>；反之大于。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Algorithm <span class="number">1</span> Bisection</span><br><span class="line"><span class="comment">//Given: An interval[r_l,r_u]known to contain the optimal value of r, and tolerance e&gt;0.</span></span><br><span class="line"><span class="keyword">while</span>(r_u - r_l &gt; e)</span><br><span class="line">    &#123;</span><br><span class="line">        r = (r_l + r_u)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//Solve the SOCP feasibility problem(11)</span></span><br><span class="line">        <span class="keyword">if</span> feasible </span><br><span class="line">            r_u = r;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">            r_l = r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="得到socp问题">得到SOCP问题</h3><p>我们希望把问题组织成(12)的形式，因为我们现在知道如何求解此类问题。实际中，我们遇到的绝大部分方程是如下形式的：<span class="math display">\[\frac{(g_1(x)^2+g_2(x)^2)^{1/2}}{g_3(x)}\]</span> 其定义域为 <spanclass="math inline">\(\{x|g_3(x)&gt;0)\}\)</span>，且<spanclass="math inline">\(g_i(x)\)</span> 为仿射函数，即 <spanclass="math inline">\(g_i(x)=a_i^Tx+b_i\)</span>。因此，(15)可以写成<span class="math inline">\({\left\| A_ix+b_i\right\|_2}/{c_i^Tx+d_i}\)</span> ，其中 <span class="math inline">\(A =(a_1^T;a_2^T)\)</span> 。</p><h2 id="参考文献">参考文献</h2><section class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>Kahl F, Hartley R. Multiple-ViewGeometry Under the <span class="math inline">\(L_{\infty}\)</span>Norm[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence,2008, 30(9): 1603-1617.<a href="#fnref1" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>R. I. Hartley and P. Sturm.Triangulation. Computer Vision and Image Understanding, 68(2):146–157,<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>H. Stewénius, F. Schaffalitzky, andD. Nistér. How hard is three-view triangulation really? In Int.Conf.Computer Vision, pages 686–693, Beijing, China, 2005.<a href="#fnref3"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p>R. I. Hartley and P. Sturm.Triangulation. Computer Vision and Image Understanding, 68(2):146–157,<ahref="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 文献研读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多视几何 </tag>
            
            <tag> 无穷范数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何处理中的非线性优化方法</title>
      <link href="/posts/c09bba4a.html"/>
      <url>/posts/c09bba4a.html</url>
      
        <content type="html"><![CDATA[<p>许多基本的物理和几何任务需要最小化网格变形能量。</p><h2 id="算法要求requirement">算法要求(Requirement)</h2><ul><li><em>robust</em></li><li><em>efficient</em></li><li><em>automated</em></li></ul><h2 id="算法难点difficulties">算法难点(Difficulties)</h2><ul><li>适应性的混合的二阶能量近似表示</li><li>线性搜索前barrier-aware的过滤器</li><li>梯度范数收敛准则</li></ul><span id="more"></span><h2 id="问题陈述problem-statement">问题陈述(Problem Statement)</h2><p>几何优化问题通常要解决： <span class="math display">\[x^{*}=\underset{x \in \mathbb{R}^{d n}}{\operatorname{argmin}} E(x)\]</span> <span class="math inline">\(x\)</span> 是 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(d\)</span> 维的坐标组成的向量，<spanclass="math inline">\(E(x)\)</span> 表示对形变的度量： <spanclass="math display">\[E(x)=\sum_{t \in T} a_{t} W\left(F_{t}(x)\right)\]</span> <span class="math inline">\(a_{t}\)</span> 表示元素 <spanclass="math inline">\(t\)</span> 在静止形态(<em>restshape</em>)时的面积，<span class="math inline">\(W\)</span>是一个能量密度函数(<em>energy densityfunction</em>)，参数是变形梯度，<spanclass="math inline">\({F_t}\)</span> 为每个元素 <spanclass="math inline">\(t\)</span> 计算了变形梯度。</p><h2 id="迭代求解器iterative-solvers">迭代求解器(Iterative solvers)</h2><p>有三个主要部分：</p><ul><li><p><strong>能量近似(<em>Energy Approximation</em>)</strong></p><p>在每个迭代过程 <span class="math inline">\({i}\)</span>中，对能量做一个二阶近似(<em>proxy</em>)： <span class="math display">\[E_{i}(x)=E\left(x_{i}\right)+\left(x-x_{i}\right)^{T} \nablaE\left(x_{i}\right)+\frac{1}{2}\left(x-x_{i}\right)^{T}H_{i}\left(x-x_{i}\right)\]</span> <span class="math inline">\({H_i}\)</span>是一个对称矩阵，如果他能准确的近似Hessian矩阵，迭代就可以快速收敛，确保<span class="math inline">\({H_i}\)</span> 对称正定(symmetric positivedefinite,SPD)也同样关键。我们想要得到一个容易计算的，稀疏的，不用在每次迭代重新分解的<span class="math inline">\({H_i}\)</span> 矩阵。</p></li><li><p><strong>线性搜索(<em>Line Search</em>)</strong></p><p>二阶的能量近似模型使得我们可以使用线性求解器寻找 <spanclass="math inline">\(x_{i}^{*}\)</span> ，每一步为： <spanclass="math display">\[p_{i}=x_{i}^{*}-x_{i}=-H_{i}^{-1} \nabla E\left(x_{i}\right)\]</span>但是，通常对于非线性的能量，二阶能量近似只在局部比较精确，所以需要用line-search寻找一个<span class="math inline">\(\alpha_i&gt;0\)</span> ，使得 <spanclass="math inline">\(x_{i}^{*}\)</span> 在 <spanclass="math inline">\({x_i}\)</span>的邻域内，从而可以忽略掉泰勒展开的高次项，这样就得到了一个新的迭代：<span class="math display">\[x_{i+1} \leftarrow x_{i}+\alpha_{i} p_{i}\]</span>在几何问题中，需要特别注意一个现象，对于退化(如翻转)的元素，能量通常会急速增加至无穷。如果某一个<span class="math inline">\(p_i\)</span> 使得元素有这种退化趋向，则<span class="math inline">\(\alpha_i\)</span>需要非常小，来阻止这种迭代。</p></li><li><p><strong>收敛条件(<em>Termination</em>)</strong></p><p>通常的迭代停止条件是，检查能量梯度的范数，然而，梯度范数与Mesh网的大小、尺度、能量的表示方法等相关联，很难选取一个固定的阈值。</p></li></ul><h2 id="常用能量energies">常用能量(Energies)</h2><ul><li><p><strong>Isometric</strong></p><ul><li>[Sorkine and Alexa 2007]</li><li>[Chao et al. 2010]</li><li>[Smith and Schaefer 2015]</li><li>[Aigerman et al. 2015]</li><li>[Liu et al. 2008]</li></ul></li><li><p><strong>Conformal</strong></p><ul><li>[Hormann and Greiner 2000]</li><li>[L´evy et al. 2002]</li><li>[Desbrun et al. 2002]</li><li>[Ben-chen et al. 2008]</li><li>[Mullenet al. 2008]</li><li>[Weber et al. 2012]</li></ul></li><li><p><strong>Do not prohibit inversion</strong></p><ul><li>[Sorkine and Alexa 2007]</li><li>[Chao et al. 2010]</li><li>[L´evy et al. 2002]</li><li>[Desbrun et al. 2002]</li></ul></li><li><p><strong>Use non-convex terms guarantee preservation of localinjectivity</strong></p><ul><li>[Hormann and Greiner 2000]</li><li>[Aigerman et al. 2015]</li><li>[Smith and Schaefer 2015]</li></ul></li><li><p><strong>Currently critical in geometry processing</strong></p><ul><li><p>Symmetric Dirichlet (ISO) [Smith and Schaefer 2015]</p></li><li><p>Conformal Distortion (CONF) [Aigerman et al. 2015]</p></li><li><p>Most-Isometric Parameterizations (MIPS) [Hormann and Greiner2000]</p></li></ul></li></ul><h2 id="能量近似energy-approximations">能量近似(EnergyApproximations)</h2><p>对能量的近似在这里就转化为对 <span class="math inline">\(H_i\)</span>的近似，主要有以下几种方法：</p><ul><li><p><strong>牛顿法(<em>Newton-type methods</em>)</strong></p><p>牛顿法通常能够得到最快的收敛速度，但是每次迭代的计算成本非常高。它直接用能量函数的海塞矩阵组成<span class="math inline">\(H_i\)</span> ，这对于 <em>凸能量函数</em>有较好的效果，如 <em>ARAP</em> ，但是对于<em>非凸能量函数</em>需要进行改进，至少要确保 <span class="math inline">\(H_i\)</span>是半正定(positive semidefinite,PSD)的。针对非凸能量函数改进的算法有：</p><ul><li>CM (Composite Majorization)</li><li>PN (Projected Newton)</li></ul><p>虽然上述两种方法需要的迭代次数较少，但是我们在试图解决大的优化问题时，它们每次迭代的成本和存储空间的增长都令人望而却步。</p></li><li><p><strong>一阶法(<em>First-order methods</em>)</strong></p><p>Direct gradient descent, Jacobi-preconditioned gradient descent</p><ul><li>SGD (Sobolev-preconditioned gradient descent) Laplacian matrix</li><li>AQP (Accelerated Quadratic Proxy)</li></ul></li><li><p><strong>伪牛顿法(<em>Quasi-Newton Methods</em>)</strong></p><p>lie in between these two extremes</p><ul><li>L-BFGS</li></ul></li><li><p><strong>几何近似法(<em>Geometric ApproximationMethods</em>)</strong></p><ul><li>SLIM</li><li>AKAP</li></ul></li></ul><h2 id="线性搜索line-search">线性搜索(Line search)</h2><p>当我们得到搜索方向时，通常想要使用一个大的步长，来最大化下降效果。但是对于非线性的能量函数，太大的步长可能适得其反，偶尔会使得能量增加。几何处理和物理领域中绝大多数的能量函数是由有理分式组成的，</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非线性优化 </tag>
            
            <tag> Mesh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影测量与计算机视觉基础知识</title>
      <link href="/posts/fa8967fc.html"/>
      <url>/posts/fa8967fc.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础坐标系">基础坐标系</h2><p><strong><em>摄影测量：</em></strong></p><ul><li><p><strong>像方</strong></p><ul><li><p><strong>像平面坐标系</strong></p><p>以主点为原点的右手平面坐标系，用<spanclass="math inline">\(o\text{-}xy\)</span>表示。注意，主点为摄影中心在像平面上的投影点，其不一定位于图像中心。</p></li></ul><span id="more"></span><ul><li><p><strong>框标平面坐标系</strong></p><p>以框标连线交点为原点的右手平面坐标系，用<spanclass="math inline">\(P\text{-}xy\)</span>表示。需要注意的是现代的数字影像早已取消了框标，因此这个坐标系现今是指以图像中心为原点的右手平面坐标系，与计算机视觉中的图像坐标系类似。在实际应用中通常采用该坐标系来表示像点的位置，而在摄影测量解析计算中，像点的坐标应采用以像主点为原点的像平面坐标系中的坐标，因此，当像主点与图像中心不重合时，须将框标平面坐标系原点平移至像主点。</p></li><li><p><strong>像空间坐标系</strong></p><p>以摄影中心<span class="math inline">\(S\)</span>为坐标原点，<spanclass="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span>轴与像平面坐标系的<spanclass="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span>轴平行，<spanclass="math inline">\(z\)</span>轴与光轴重合，形成像空间右手直角坐标系<spanclass="math inline">\(S\text{-}xyz\)</span>。</p></li><li><p><strong>像空间辅助坐标系</strong></p><p>像点的像空间坐标可以直接从像面平面坐标得到<spanclass="math inline">\((x,y,\text{-}f)\)</span>，但由于各个相片的像空间坐标系不统一，不便于计算，因此需要建立一种相对统一的坐标系即像空间辅助坐标系<spanclass="math inline">\(S\text{-}uvw\)</span>。其坐标原点仍取摄影中心<spanclass="math inline">\(S\)</span>，坐标轴依情况而定，通常有三种选取方法：</p><ol type="1"><li>取<span class="math inline">\(u\)</span>、<spanclass="math inline">\(v\)</span>、<spanclass="math inline">\(w\)</span>各轴分别平行于地面摄影测量坐标系<spanclass="math inline">\(D\text{-}XYZ\)</span>；</li><li>以每条航线的第一张相片的像空间坐标系作为像空间辅助坐标系；</li><li>以每个像片对的左片作为<spanclass="math inline">\(uw\)</span>平面，过原点且垂直于<spanclass="math inline">\(uw\)</span>平面的轴为v构成右手直角坐标系。</li></ol></li></ul></li><li><p><strong>物方</strong></p><ul><li><p><strong>大地测量坐标系</strong></p><p>大地测量坐标系（地面测量坐标系）通常是指空间大地坐标基准下的空间左手直角坐标系，用<spanclass="math inline">\(T\text{-}X_tY_tZ_t\)</span>表示。摄影测量方法求得的地面点坐标最后要以此坐标形式提供给用户。</p></li><li><p><strong>地面摄影测量坐标系</strong></p><p>因像空间辅助坐标系是右手系，大地测量坐标系是左手系，两者之间转换困难，因此建立了地面摄影测量坐标系作为过渡性坐标系，用<spanclass="math inline">\(D\text{-}XYZ\)</span>表示。<spanclass="math inline">\(X\)</span>轴方向大致与航向一致，<spanclass="math inline">\(Y\)</span>轴与<spanclass="math inline">\(X\)</span>轴正交，<spanclass="math inline">\(Z\)</span>轴与<spanclass="math inline">\(XY\)</span>构成右手系。</p></li></ul></li></ul><p><strong><em>计算机视觉：</em></strong></p><ul><li><p><strong>像方</strong></p><ul><li><p><strong>像素坐标系</strong></p><p>以图像左上角为原点建立的坐标系<spanclass="math inline">\(uv\)</span>,单位为<spanclass="math inline">\(pixel\)</span>。</p></li><li><p><strong>图像坐标系</strong></p><p>类似摄影测量中的框标平面坐标系，以图像中心为原点，表示方法为<spanclass="math inline">\(o\text{-}xy\)</span>，单位为<spanclass="math inline">\(mm\)</span>。</p></li><li><p><strong>相机坐标系</strong></p><p>类似与摄影测量中的像空间辅助坐标系，以相机的光心为坐标原点，<spanclass="math inline">\(X\)</span>轴和<spanclass="math inline">\(Y\)</span>轴分别平行于图像坐标系的<spanclass="math inline">\(x\)</span>轴和<spanclass="math inline">\(y\)</span>轴，相机的光轴为<spanclass="math inline">\(Z\)</span>轴，表示方法为<spanclass="math inline">\(O_c\text{-}X_cY_cZ_c\)</span>。</p></li></ul></li><li><p><strong>物方</strong></p><ul><li><p><strong>世界坐标系</strong></p><p>类似与摄影测量中的地面摄影测量坐标系，表示方法为<spanclass="math inline">\(O_w\text{-}X_wY_wZ_w\)</span>。</p></li></ul></li></ul><h2 id="基本概念">基本概念</h2><ul><li><p><strong>畸变系数</strong></p><p>​镜头畸变分为径向畸变和切向畸变。径向畸变的产生原因是光线在远离透镜中心的地方比靠近中心的地方更加弯曲，其畸变系数为<spanclass="math inline">\(k_1,k_2,k_3\)</span>；切向畸变产生的原因是透镜不完全平行于图像平面，其畸变系数为<spanclass="math inline">\(p_1,p_2\)</span>。</p></li><li><p><strong>内方位元素</strong></p><p>​内方位元素是描述摄影中心与相片之间相关位置的三个参数，即摄影中心<spanclass="math inline">\(s\)</span>到相片的垂距<spanclass="math inline">\(f\)</span>，以及像主点（摄影中心垂直投影到相片上的一点）在图像坐标系中的坐标<spanclass="math inline">\(x_0,y_0\)</span>。</p></li><li><p><strong>外方位元素</strong></p><p>​外方位元素是描述相片在摄影瞬间的空间位置和姿态的六个参数，包括三个直线元素和三个角元素。三个直线元素用于描述摄影中心的空间坐标值<spanclass="math inline">\(X_s\)</span>, <spanclass="math inline">\(Y_s\)</span>, <spanclass="math inline">\(Z_s\)</span>，三个角元素用于描述像片的空间姿态<span class="math inline">\(\omega\)</span>, <spanclass="math inline">\(\varphi\)</span>, <spanclass="math inline">\(\kappa\)</span>。</p></li><li><p><strong>相对定向元素</strong></p><p>​相对定向元素是指确定摄影瞬间相邻两像片间相对位置和姿态的参数，相对定向元素共有五个，这五个相对定向元素随着所选取的像空间辅助坐标系的不同而不同，通常有两种不同的表达形式，下文会详细说明。</p></li><li><p><strong>绝对定向元素</strong></p><p>​绝对定向元素是指确定立体模型对于物方空间的方位和比例所需要的独立参数，绝对定向元素共有七个，包括一个比例尺缩放分量，三个旋转分量和三个平移分量。</p></li><li><p><strong>投影</strong></p><p>​投影是指实际像点去镜头畸变转换成理想像点再转换成物点的过程。</p></li><li><p><strong>重投影</strong></p><p>​重投影是指物点转换成理想像点加镜头畸变再转换成实际像点的过程。</p></li><li><p><strong>光心</strong></p><p>​ 光心即摄影中心（投影中心）。</p></li><li><p><strong>基线</strong></p><p>​ 基线是指两相片摄影中心的连线。</p></li><li><p><strong>核面</strong></p><p>​ 核面（极面）是指通过摄影基线与任一物方点所作的平面。</p></li><li><p><strong>核线</strong></p><p>​ 核线（极线）是指核面与像面的交线。</p></li><li><p><strong>核点</strong></p><p>​ 核点（极点）是指摄影基线与像平面的交点。</p><p>要明确摄影测量的最终目标是由像点坐标计算得到其对应的物点坐标，以此来建立三维模型。</p></li></ul><h2 id="共线方程后方交会前方交会">共线方程、后方交会、前方交会</h2><p><strong><em>摄影测量：</em></strong></p><ul><li><p><strong>共线方程</strong></p><p>​共线方程是指根据投影中心、像点、物点三点共线的几何关系所建立的方程，将像点坐标、物点坐标与内外方位元素联系了起来。</p></li><li><p><strong>后方交会</strong></p><p>​ 恢复相片外方位元素的过程即为后方交会。</p></li><li><p><strong>前方交会</strong></p><p>​由两张相片的内外方位元素及像点坐标求得对应物点坐标的过程即为前方交会。</p></li></ul><p><strong><em>计算机视觉：</em></strong></p><p>​下面让我们想象一个<strong>重投影</strong>的过程，即由物点坐标一步步求得像点坐标的过程。</p><p><strong>Step1: 世界坐标系 -&gt; 相机坐标系</strong></p><p>先平移再旋转： <span class="math display">\[\begin{bmatrix}X_c\\Y_c\\Z_c\end{bmatrix}=R\left(\begin{bmatrix}X_w\\Y_w\\Z_w\end{bmatrix}-\begin{bmatrix}X_s\\Y_s\\Z_s\end{bmatrix}\right)\]</span></p><p>先旋转再平移： <span class="math display">\[\left[\begin{array}{c}X_{c} \\Y_{c} \\Z_{c}\end{array}\right]=R\left[\begin{array}{c}X_{w} \\Y_{w} \\Z_{w}\end{array}\right]+t \quad \rightarrow \quad\left[\begin{array}{c}X_{c} \\Y_{c} \\Z_{c} \\1\end{array}\right]=\left[\begin{array}{cc}R &amp; t \\0 &amp; 1\end{array}\right]\left[\begin{array}{c}X_{w} \\Y_{w} \\Z_{w} \\1\end{array}\right]\]</span></p><ul><li><p><strong>R矩阵</strong></p><p>​ R矩阵用来描述两个坐标系之间的旋转关系。</p></li><li><p><strong>C矩阵</strong></p><p>​ C矩阵指投影中心在世界坐标系下的坐标。</p><p><span class="math display">\[C=\left[\begin{array}{c}X_{s} \\Y_{s} \\Z_{s}\end{array}\right]\]</span></p></li><li><p><strong>t向量</strong></p><p>​t向量用来描述两个坐标系之间的平移关系，指在相机坐标系下世界坐标系原点的位置。</p><p><span class="math display">\[t=-RC\]</span></p></li></ul><p><strong>Step2: 相机坐标系 -&gt; 图像坐标系</strong> <spanclass="math display">\[\frac{x}{X_{c}}=\frac{y}{Y_{c}}=\frac{f}{Z_{c}}\]</span></p><p><span class="math display">\[\left[\begin{array}{l}x \\y \\1\end{array}\right]=\left[\begin{array}{c}\frac{f X_{\mathrm{c}}}{Z_{c}} \\\frac{f Y_{c}}{Z_{c}} \\1\end{array}\right]=\frac{1}{Z_{c}}\left[\begin{array}{ccc}f &amp; 0 &amp; 0 \\0 &amp; f &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{l}X_{c} \\Y_{c} \\Z_{c}\end{array}\right]\]</span></p><p><span class="math display">\[\left[\begin{array}{c}x-x_{0} \\y-y_{0} \\1\end{array}\right]=\left[\begin{array}{c}\frac{f X_{\mathrm{c}}}{Z_{c}} \\\frac{f Y_{c}}{Z_{c}} \\1\end{array}\right]=\frac{1}{Z_{c}}\left[\begin{array}{ccc}f &amp; 0 &amp; 0 \\0 &amp; f &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{c}X_{c} \\Y_{c} \\Z_{c}\end{array}\right]\]</span></p><p><span class="math display">\[Z_{c}\left[\begin{array}{l}x \\y \\1\end{array}\right]=\left[\begin{array}{ccc}f &amp; 0 &amp; x_{0} \\0 &amp; f &amp; y_{0} \\0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{l}X_{c} \\Y_{c} \\Z_{c}\end{array}\right]\]</span></p><p><span class="math display">\[Z_{c}\left[\begin{array}{l}x \\y \\1\end{array}\right] =K R\left(\left[\begin{array}{l}X_{w} \\Y_{w} \\Z_{w}\end{array}\right]-\left[\begin{array}{l}X_{S} \\Y_{S} \\Z_{S}\end{array}\right]\right)=K R\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -X_{S} \\0 &amp; 1 &amp; 0 &amp; -Y_{S} \\0 &amp; 0 &amp; 1 &amp; -Z_{S}\end{array}\right]\left[\begin{array}{c}X_{w} \\Y_{w} \\Z_{w} \\1\end{array}\right]=P\left[\begin{array}{c}X_{w} \\Y_{w} \\Z_{w} \\1\end{array}\right]\]</span></p><ul><li><p><strong>K矩阵</strong> <span class="math display">\[K=\left[\begin{array}{ccc}f &amp; 0 &amp; x_{0} \\ 0 &amp; f &amp; y_{0}\\ 0 &amp; 0 &amp; 1\end{array}\right]\]</span></p></li><li><p><strong>T矩阵</strong> <span class="math display">\[T=R[I \mid-C]=[R \mid t]\]</span></p></li><li><p><strong>P矩阵</strong> <span class="math display">\[P=K R\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; -X_{S} \\ 0 &amp;1 &amp; 0 &amp; -Y_{S} \\ 0 &amp; 0 &amp; 1 &amp;-Z_{S}\end{array}\right]=K R[I \mid-C]=K [R \mid t ]=KT\]</span></p></li></ul><h2 id="共面方程相对定向绝对定向">共面方程、相对定向、绝对定向</h2><p><strong><em>摄影测量：</em></strong></p><ul><li><strong>共面方程</strong></li><li><strong>相对定向</strong></li><li><strong>绝对定向</strong></li></ul><p><strong><em>计算机视觉：</em></strong></p><ul><li><strong>E矩阵</strong></li><li><strong>F矩阵</strong></li><li><strong>H矩阵</strong></li></ul><p>更不动了，哪天有空了再更。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影测量 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
